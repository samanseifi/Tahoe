#!/usr/bin/perl -w
# $Id: tahoe-manager,v 1.74 2013/08/01 19:41:27 regueiro Exp $
#
#------------------------------------------------------------------------------
# tahoe-manager: 
#    a PERL script to checkout, configure, build and run regression tests
#    for TAHOE
# written by: 
#    Reese Jones (rjones@sandia.gov) and Patrick Klein (patrickklein@mac.com)
#------------------------------------------------------------------------------

use Cwd; # $home = cwd();

# tahoe server
#$tahoe = "tahoe.ca.sandia.gov"; 

# Sourceforge server
$tahoe_sf = "tahoe.cvs.sourceforge.net"; 

# Colorado server
#$tahoe_co = "tahoe.colorado.edu"; 

# Cloudforge server
$tahoe_cld = "tahoe.cvs.cvsdude.com"; 

# core modules (for rebuild)
@core_modules = (
"toolbox",
"tahoe");

# modules in order of dependency
@modulebydepend = (
"access",
"SIMOD",
"macros", 
"expat", 
"f2c",
"CBLAS",
"aztec",
"metis",
"spooles",
"spoolesMPI",
"spoolesMT",
"SuperLU_CBLAS",
"SuperLU",
"SuperLU_DIST",
"Trilinos",
"toolbox",
"development",
"tahoe",
"contrib",
"benchmark_XML",
"development_benchmark_xml",
"bravais");

# prefix on macros in the makefiles
# NOTE: macro prefixes must be unique when compared as regular expressions,
#       i.e., ($macro_i =~ /$macro_j/) should not return true if i != j. This
#       means macro prefix names cannot be sub-strings of other macro prefixes.
%module2define = qw(
expat	EXPAT_
toolbox	TB_
tahoe	TAHOE_
macros	NODEFINE
spooles SPOOLES_
spoolesMPI SPOOLESMPI_
spoolesMT SPOOLESMT_
metis   METIS_
aztec   AZ_
f2c	F2C_
CBLAS	BLAS_
access	AX_
development DEV_
contrib NODEFINE
benchmark_XML NODEFINE
development_benchmark_xml NODEFINE
SIMOD SIMOD_
bravais NODEFINE
SuperLU_CBLAS SUPERLUCBLAS_
SuperLU SUPERLU_
SuperLU_DIST SUPERLUDIST_
Trilinos TRILINOS_
);

# location of module on the server
%module2repo = qw(
expat		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
toolbox		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
tahoe		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
macros		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
spooles		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
spoolesMPI	tahoe.cvs.sourceforge.net:/cvsroot/tahoe
spoolesMT	tahoe.cvs.sourceforge.net:/cvsroot/tahoe
metis		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
aztec		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
f2c		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
CBLAS		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
access		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
development	tahoe.cvs.cvsdude.com:/tahoe 
benchmark_XML	tahoe.cvs.sourceforge.net:/cvsroot/tahoe
development_benchmark_xml tahoe.cvs.cvsdude.com:/tahoe
contrib		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
bravais		tahoe.cvs.sourceforge.net:/cvsroot/tahoe
SuperLU_CBLAS tahoe.cvs.sourceforge.net:/cvsroot/tahoe
SuperLU       tahoe.cvs.sourceforge.net:/cvsroot/tahoe
SuperLU_DIST  tahoe.cvs.sourceforge.net:/cvsroot/tahoe
);

# "touch" targets
%module2touch = qw(
spooles touch_spooles
spoolesMPI touch_spooles
spoolesMT touch_spooles
aztec touch_Aztec
f2c touch_f2c
access touch_SEACAS
metis touch_METIS
SIMOD touch_SIMOD
SuperLU touch_SuperLU
SuperLU_DIST touch_SuperLU
Trilinos touch_TRILINOS
);

# modules in the UP_TO_DATE macro
%up_to_date_modules = qw(
development 1
);

# modules available via http
%http_modules = qw(
macros 1
expat 1
toolbox 1
tahoe 1
benchmark_XML 1
metis 1
spooles 1
spoolesMPI 1
spoolesMT 1
contrib 1
);

# build directories buried within modules. Should not be defined
# for modules where the makefile to build the module resides in the
# top-level of each module
%module2targets = (
	'benchmark_XML' => ['benchmark_XML/comparator'],
	'contrib' => ['contrib/translate', 'contrib/wrap', 'contrib/MakeCSE', 'contrib/Dakota']
);

# classify modules
@defaultmodules = ("macros","expat","toolbox","tahoe"); # min req'd install
@allmodules = sort(keys(%module2define));
@optionalmodules = complement(\@allmodules, \@defaultmodules);
#@activemodules = ("toolbox","tahoe","development");
#@staticlibs = complement(\@allmodules, \@activemodules);
@nonbuildmodules = ("macros");

# %syslib2module = qw(
# ACCESS	access
# SIMOD_HOME   SIMOD
# TRILINOS_HOME Trilinos
# );

%module2syslib = qw(
access ACCESS
SIMOD  SIMOD_HOME
Trilinos TRILINOS_HOME
);

#%connect2command = qw(
#cvs     cvs
#http	curl
#);

# default configuration file
$config_file = "./.tahoe_config";

$time = localtime();
print "* running tahoe-manager script at $time\n";

# required command lines tools
@required_tools = ("cvs", "make");
foreach my $tool (@required_tools) {
	`$tool 2>&1`;
	if ($? == -1) {
		print "ERROR: test for \"$tool\" failed with \"$!\"\n";
		print "ERROR: verify installed tools and paths\n";
		exit;
	}
}

# if TAHOE_HOME is set, change to that location
$tahoe_home = cwd();
if(defined($dir = findENV("TAHOE_HOME") ) ) {
	$tahoe_home = $dir;
	print "* changing to directory TAHOE_HOME = $tahoe_home\n";
	chdir $tahoe_home;
}

# initialization
$count = 0;
initialize();

# loop through arguments and options
$script_status = 0;
if (@ARGV < 1) {usage(); exit 0;}
ARG: while (@ARGV) {
	OPT: for (shift@ARGV) {
		$count = @ARGV;
		if ($script_status > 0 )   { failed();}
		if (/^u|^update/i)          { update(); next ARG; }
		if (/^co|config/i)         { config(); next ARG; }
		if (/^i|init/i)            { init(); next ARG; }
		if (/^b|^build/i)           { build(); next ARG; }
		if (/^r|rebuild/i)         { rebuild(); next ARG; }
		if (/^t|test/i)            { test(); next ARG; }
		if (/^cl|clean/i)          { clean(); next ARG; }
		if (/^u|usage|help|^h/i)   { usage();}
		if (/^s|selfupdate/i)      { selfupdate(); exit 0; }
		print "ERROR: unknown option: $_ \n"; usage();
	}
}

exit 0;

###############################################################################
sub selfupdate {
	if ($connection =~ /cvs/) {
		print "updating...\n";
		do_system("cvs -q update tahoe-manager");
	} else {
		print "no selfupdate for connection $connection\n";
	}
}

###############################################################################
sub initialize {

# configuration file
if(-e "$config_file") { read_config(); }
else                  { write_default_config(); }

# verify macros module
unless(-d "macros") {
	print "checking out macros...";
	update("macros");
	print " ok\n";
}

# remove system libraries from @modules
#foreach my $lib (@syslibs) {
#	for (my $i = 0; $i < scalar(@modules) ; $i++) {
#		if ($modules[$i] eq $syslib2module{$lib}) { splice (@modules,$i,1); }
#	}
#}

# check for missing required modules
my @req_missing = get_missing_modules();
while (scalar(@req_missing) > 0) {
	print "adding required modules: @req_missing\n";
	foreach my $mod (@req_missing) {
		push(@modules, $mod);
	}
	write_config();
	@req_missing = get_missing_modules();
}

# search for required system libs
foreach my $module (@modules) {
	if (defined($module2syslib{$module})) { # is syslib that requires environmental variable
		my $syslib = $module2syslib{$module};
		if (defined($ENV{$syslib})) {
			print "* found system library $syslib \@ $ENV{$syslib}\n"; 		
		} else {
			print STDOUT "ERROR: missing environmental variable $syslib needed for module $module\n";
			exit 1;
		}
	}
}

# foreach my $key (sort(keys %ENV)) {
# 	foreach my $lib (keys %syslib2module) {
# 		if ($key =~ /$lib/ ) { 
# 			my $loc = $ENV{$key};
# 			print "* found system library $lib \@ $loc \n"; 
# #			push(@syslibs,$lib);
# 		}
# 	}
# }

print "*--------------------------------------------------\n";
print "* Sourceforge username: $tahoe_sf_name\@$tahoe_sf\n";
#print "* Tahoe server name: $tahoe_name\@$tahoe\n";
#print "* Colorado server name: $tahoe_co_name\@$tahoe_co\n";
print "* Cloudforge tahoe.username: $tahoe_cld_name\@$tahoe_cld\n";
#print "*   connection: $connection\n";
if ($proxy !~ "NONE") {
	print "*             proxy: $proxy\n";
}
print "*      architecture: $arch \n"; 
print "*--------------------------------------------------\n";

# check connection method
#open(WHICH, "which $connect2command{$connection} |");
#if (my_which($connect2command{$connection}) =~ "") {
#	print "ERROR: command \"$connect2command{$connection}\" not found\n";
#	if ($connection =~ "http") {
#		print "ERROR: curl is available from http://curl.haxx.se/\n";
#	}
# 	exit;
#}

# check cvs settings
if ($connection =~ "cvs") {
	my $cvs_OK = 0;
	foreach my $key (sort(keys %ENV)) {
		if ($key =~ "CVS_RSH" && $ENV{$key} =~ "ssh") { $cvs_OK = 1; }
	}
	if ($cvs_OK != 1) {
		print "ERROR: CVS_RSH must be set to ssh\n";
		exit;
	}
}
}

##############################################################################
sub config {
	@config_options = (
#		"add optional modules", 
#		"remove optional modules", 
		"add/remove optional modules",
		"configure options within modules");

	my @mods = @modules;
	print "\n> installed modules: @mods\n";
	print "configuration options:\n";
	my $i = 0;
	foreach my $option (@config_options) {
		print "$i $option\n"; 
		$i++
	}
	
	my $change = 0;
	print "\nchoice: ";
	my $choice = <STDIN>;
#	if ($choice =~ /0/) {
#		$change = add_optional_modules();
#		write_config();
#	} elsif ($choice =~ /1/) {
#		$change = remove_optional_modules();
#		write_config();
#	} elsif ($choice =~ /2/) {
	if ($choice =~ /0/) {
		$change = config_optional_modules();
		write_config();
	} else {
		$change = module_config();
	}
	
	# rewrite configuration file
	write_config();
	print "\n* changes won't take effect until next build\n\n" if ($change > 0);
}

##############################################################################
sub read_config{
print "* reading config file $config_file\n";
open(CONFIG,$config_file) || die "cannot open file $config_file for reading : $!";
my $type = "UNKNOWN";
#$tahoe_co_name = 'NONE';
$tahoe_cld_name = 'NONE';
while(<CONFIG>) {
	s/^\s+//; s/\s+$//; @list = split(/ +/);
 	if (defined($list[0])){
        	if (/^\#/ ){ 
			if ($type  =~ /CONNECTION/) {$connection = $tmp_list[0];}
#			elsif ($type =~ /TAHOE_LOGIN/) { $tahoe_name = $tmp_list[0]; }
			elsif ($type =~ /TAHOE_SF_LOGIN/) { $tahoe_sf_name = $tmp_list[0]; }
#			elsif ($type =~ /TAHOE_CO_LOGIN/) { $tahoe_co_name = $tmp_list[0]; }
			elsif ($type =~ /TAHOE_CLD_LOGIN/) { $tahoe_cld_name = $tmp_list[0]; }
			elsif  ($type  =~ /PROXY/){$proxy = $tmp_list[0];}
			elsif  ($type  =~ /ARCH/){$arch = $tmp_list[0];}
			elsif  ($type  =~ /USE_DEFAULT/){$use_default_arch = $tmp_list[0];}
			elsif  ($type  =~ /VERBOSE/){ $verbose = $tmp_list[0]; }
 			elsif  ($type  =~ /MODU/){@modules = @tmp_list;}
 			elsif ($type =~ /TAHOE_HOME/) { $tahoe_home = $tmp_list[0]; }
 			$type = $list[1]; @tmp_list =();
 		} 
 		else { push(@tmp_list,@list);}
 	}
}
close(CONFIG);

# make sure nothing has moved
my $cwd = cwd();
if ($cwd ne $tahoe_home) {
	print "\nERROR: installation directory has moved:\n";
	print "ERROR: old $tahoe_home\n";
	print "ERROR: now $cwd\n";
	print "ERROR: execute \"tahoe-manager clean\" to reinitialize\n\n";
	exit;
}

# need to make sure the core modules exist
my @missing_core = complement(\@defaultmodules, \@modules);
if (scalar(@missing_core) > 0) {
	print "* adding : @missing_core to modules\n" ; 
	foreach my $mod (@missing_core) {
		push (@modules, $mod);
	}
	write_config();
}
}

##############################################################################
sub write_default_config{
print "* creating default config file $config_file\n";

# look for environmental settings
my $cvs_rsh;
$verbose = "false";
$use_default_arch = "true";
$tahoe_name = "nobody";
foreach my $key (sort(keys %ENV)) {
	my $value =  $ENV{$key};
	if ($key =~ "TAHOE_CONNECT" ) {
		print "* found environmental var : $key = $value\n";
		$connection = $value;}
	if ($key =~ "TAHOE_ARCH") { 
		print "* found environmental var : $key = $value\n";
		$arch = $value; }
	if ($key =~ "CVS_RSH") { 
		print "* found CVS_RSH env var, using cvs connection\n"; 
		$cvs_rsh = $value; }
	
	# get user name on local machine
	if ($key eq USER) {
		$tahoe_name = $value;
		# the builtin function getlogin() sometimes returns the wrong name
	}
}

# connection type
$proxy = "NONE";
unless(defined($connection)) { 

# all connections are cvs now
#	@connections = ("cvs", "http");
#	my $i=0;
#	foreach my $choice (@connections) { 
#		print "$i $choice\n"; 
#		$i++; 
#	}
#	my $connect_default = 1;
#	$connect_default = 0 if (defined($cvs_rsh));
#	print "connection type [$connect_default]: ";
#	$i = <STDIN>; 
#	chomp($i);
#	if (length($i) == 0) { # default
#		$i = $connect_default;
#	}
#	$connection = $connections[$i];
	$connection = "cvs";

	if ($connection =~ "http") { # ask for proxy
		print "http proxy (proxyhost:port) [NONE]:";
		$proxy = <STDIN>;
		chomp($proxy);
		if (length($proxy) == 0) { # default
			$proxy = "NONE";
		}
	}
	else {
        my $cvs_OK = 0;
        foreach $key (sort(keys %ENV)) {
                if ($key =~ "CVS_RSH" && $ENV{$key} =~ "ssh") { $cvs_OK = 1; }
        }
        if ($cvs_OK != 1) {
                print "ERROR: CVS_RSH must be set to ssh\n";
                exit;
        }
	}
}

# server login names
if ($connection =~ "cvs") {

	# Sourceforge 
	$tahoe_sf_name = "anonymous";
	print "Sourceforge server username [$tahoe_sf_name]: ";
	my $name = <STDIN>; chomp($name);
	if (length($name) > 0) {
		$tahoe_sf_name = $name;
	}
	if ($tahoe_sf_name eq "anonymous") { # do anonymous login once now
		print "\nAccess as \"anonymous\" to Sourceforge requires you to login once.\n";
		print "Press [ENTER] at the prompt to login using an empty password.\n";
		do_system("cvs -d :pserver:$tahoe_sf_name\@$tahoe_sf:/cvsroot/tahoe login");
		print "\n";
	}

	# tahoe server
#	$tahoe_name = "NONE";
#	print "Tahoe server username [NONE]: ";
#	$name = <STDIN>; chomp($name);
#	if (length($name) > 0) {
#		$tahoe_name = $name;
#	}

	# colorado server
#	$tahoe_co_name = "NONE";
#	print "Colorado server username [NONE]: ";
#	$name = <STDIN>; chomp($name);
#	if (length($name) > 0) {
#		$tahoe_co_name = $name;
#	}

	# cloudforge server
	$tahoe_cld_name = "NONE";
	print "Cloudforge tahoe.username [NONE]: ";
	$name = <STDIN>; chomp($name);
	if (length($name) > 0) {
		$tahoe_cld_name = $name;
	}
}

# get macros module
unless(-d "macros") {
	print "checking out macros...";
	update("macros");
	print " ok\n";
}

# architecture
$arch = get_arch() unless(defined($arch));
print "do want this to be the default architecture for all modules (y/n) [y]: "; 
$use_default_arch = "true";
$choice = <STDIN>;
if ( $choice =~ /n/ ) { $use_default_arch = "false"; }

# modules
@modules = @defaultmodules;
my $choice = 0;
foreach my $key (sort(keys %ENV)) {
	if ($key =~ /TAHOE_BUILD/ && $ENV{$key} =~ /default/) { $choice = 1; }
}
if ($choice != 1) {
	print "* default modules : @defaultmodules\n";

	# add optional modules
	print "do want to add optional modules (y/n) [n]: "; 
	$choice = <STDIN>;
	if ( $choice =~ /y/ ) {
#		add_optional_modules();
		config_optional_modules();
	}
}
print "\n";

# write configuration file
write_config();
}

##############################################################################
sub update{

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}
	$time = (split(/ +/,localtime()))[3];
	print "($count) updating: @run_modules, at $time\n";

	# connection type
	if ($connection =~ "cvs") {

		# check if tahoe-manager is out of date
		if (-e "CVS/Root") {
			unlink("cvs.log");
			do_system("cvs -q -n update tahoe-manager > cvs.log");
			open(IN, "cvs.log"); my @lines = <IN>; my $file = "@lines"; close(IN);
			if ($file =~ /tahoe-manager/) {
				print STDOUT "*\n* NOTE: \"tahoe-manager\" has changed. Run \"selfupdate\" to update.\n*\n";
			}
		}

		# update
		update_cvs(@run_modules);
	} elsif ($connection =~ "http") {
		update_http(@run_modules);	
	}
	else {
		print "ERROR: unrecognized connection '$connection'\n";	
		exit;
	}
}

##############################################################################
sub update_cvs {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	my $logged_in = 0;
	unlink("cvs.log");

	foreach my $dir (@run_modules) {

		next if defined($module2syslib{$dir});

		# update module that exists
		if (-d $dir) {
			if (-e "$dir/CVS/Root") { # update module with cvs
				my $cwd = cwd();
				print "\tupdating $dir...";
				chdir($dir);
				do_system("cvs -q update -Pd > $cwd/cvs.log");
				chdir($cwd);
			} else { # module was not checkout out
				print "\tmodule $dir contains no CVS information\n";
				next;
			}
		} else { # module needs to be checked out
			print "\tchecking out $dir...";
			my $repo = $module2repo{$dir};

#			if ($repo =~ /$tahoe/) { # on Tahoe server
#				if ($tahoe_name !~ /NONE/) { # must have an account
#					do_system("cvs -d $tahoe_name\@$repo -q checkout $dir > cvs.log");
#				}
#			} elsif ($repo =~ /$tahoe_sf/) { # on Sourceforge
			if ($repo =~ /$tahoe_sf/) { # on Sourceforge
				if ($tahoe_sf_name =~ /anonymous/) { # anonymous access
					do_system("cvs -z3 -d :pserver:$tahoe_sf_name\@$repo -q checkout $dir >> cvs.log");
				} else { # developer account
					do_system("cvs -z3 -d $tahoe_sf_name\@$repo -q checkout $dir > cvs.log");
				}
#			} else { # on Colorado server
#				if ($tahoe_co_name !~ /NONE/) { # must have an account
#					do_system("cvs -d $tahoe_co_name\@$repo -q checkout $dir > cvs.log");
#				}
			} else { # on Cloudforge server
				if ($tahoe_cld_name !~ /NONE/) { # must have an account
					do_system("cvs -d $tahoe_cld_name\@$repo -q checkout $dir > cvs.log");
				}
			}
		}
		# check for failures
		my ($errors, $patches, $updates, $merges) = (0, 0, 0, 0);
		open(IN,"cvs.log") || die "could not open $cwd/cvs.log";
		my $first_line = 0;
		while (defined(my $line = <IN>)) {
			my $hit = 0;
			if ($line =~ /^C /) {
				$errors++;
				$hit = 1 if ($verbose =~ /true/i);
			}
			if ($line =~ /^P /) {
				$patches++;
				$hit = 1 if ($verbose =~ /true/i);
			}
			if ($line =~ /^U /) {
				$updates++;
				$hit = 1 if ($verbose =~ /true/i);
			}
			if ($line =~ /^M /) {
				$merges++;			
				$hit = 1 if ($verbose =~ /true/i);
			}
			
			# write it
			if ($hit == 1) {
				if ($first_line == 0) {
					print "\n";
					$first_line = 1;
				}
				print $line;
			}
		}
		print "\t... " if ($first_line > 0);
		print " {U($updates), M($merges), P($patches), C($errors)}";
		if ($errors > 0) {
			$script_status++;
			print " conflicts found\n";
		} else {
			print " ok\n";
		}
		
		# mark for init
		if (-d $dir && 
			$errors + $patches + $updates + $merges > 0 && 
			$module2define{$dir} !~ "NODEFINE") {
			do_system("echo 'init' > $dir/.status");
		}
	}
}

##############################################################################
sub update_http {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	foreach $dir (@run_modules) {
	
		# check
		if (!defined($http_modules{$dir})) {
			print "ERROR: module $dir is not available via http\n";
			exit;
		}
	
		print "\tupdating $dir...\n";
		
		# grab new copy
		my $curl_cmd = "curl http://tahoe.ca.sandia.gov/download/nightly/$dir.tar.gz --remote-name --connect-timeout 10";
		if ($proxy !~ "NONE") {
			$curl_cmd = $curl_cmd." --proxy $proxy";
		}
		do_system("$curl_cmd") == 0
			or die "ERROR: curl failed. Check connection or proxy ($proxy)";

		# move existing directory aside
		if (-d $dir) {

			# parse the date
			my ($sec, $min, $hour, $mday, $mon, $year, , , ) = localtime;
			my $the_date = sprintf("%02d%02d%04d-%02d:%02d:%02d", $mon+1, $mday, $year+1900, $hour, $min, $sec);

			# rename
			if (! -d "saved") {
				do_system("mkdir saved");
			}
			do_system("mv $dir saved/$dir.$the_date");
		} 
			
		# unpack
		do_system("gunzip $dir.tar.gz");
		do_system("tar xf $dir.tar");
		if ($module2define{$dir} !~ "NODEFINE") {
			do_system("echo 'init' > $dir/.status");
		}
		
		# clean up
		do_system("rm $dir.tar");
		print " ok\n";
	}
}

##############################################################################
sub rebuild {
	$time = (split(/ +/,localtime()))[3];
	print "($count) rebuilding: @core_modules (other modules NOT checked), at $time \n";
	foreach my $dir (@core_modules) {
		print "\tmaking $dir...";
		my $cwd = cwd();
		chdir $dir; 
		do_system("make build > build.log 2>&1");
    if ($? > 0) {
			print " ERROR $?. See $dir/build.log for details.\n";
			$script_status++;
    }
		else {
			print " ok\n";
		}
		chdir($cwd);
	}
}

##############################################################################
sub build {

	# make bin directory
	do_system("mkdir bin") if (! -e "bin");

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = complement(\@modules,\@nonbuildmodules);
	}

	$time = (split(/ +/,localtime()))[3];

	# initialize modules if needed
	my @init_modules = ();
	my $tahoe_added = 0;
	my $add_tahoe = 0;
	foreach my $dir (@run_modules) {

		# skip system libraries	
		next if defined($module2syslib{$dir});
	
		my $add = 0;
		if (! -e $dir) { $add = 1; }
		elsif (! -e "$dir/makefile" && -e "$dir/makefile.template")  { $add = 1; }
		elsif (-e "$dir/.status") { 
			$add = 1; 
			
			# update tahoe
			$add_tahoe = 1 if defined($up_to_date_modules{$dir});
		}
		elsif (defined($module2targets{$dir})) { # module has nested targets
			foreach my $build_dir (@{$module2targets{$dir}}) {
				$add = 1 if (! -e "$build_dir/makefile" && -e "$build_dir/makefile.template");
			}
		}
		
		# adding tahoe
		$tahoe_added = 1 if ($add > 0 && $dir =~ "tahoe");
		
		# needs init
		push(@init_modules, $dir) if ($add > 0);
	}
	push(@init_modules, "tahoe") if ($add_tahoe > 0 && $tahoe_added == 0);
	init(@init_modules) if (scalar(@init_modules) > 0);

	# need to sort modules based on dependencies
	my @tmp_modules = sort by_depend(@run_modules);
	print "($count) building: @tmp_modules, at $time\n";

	DIR: foreach my $dir (@tmp_modules) {
		if (!defined($up_to_date_modules{$dir})) {

			my $cwd = cwd();
			my @build_dirs = ($dir);
			if (defined($module2targets{$dir})){ # module has nested targets
				@build_dirs = @{$module2targets{$dir}};
			}
			BUILD_DIR: foreach my $build_dir (@build_dirs) {
				next BUILD_DIR if (! -e "$build_dir/makefile");
				chdir $build_dir; 
				print "\tmaking $build_dir...";

				do_system("make build > build.log 2>&1");

				# check for error status
    	        if ($? > 0) {
    	     		print " ERROR $?. See $build_dir/build.log for details.\n";
    	           	$script_status++;
    	    	}
				elsif ($build_dir eq "tahoe" && !(-x "tahoe")) { 
        	       	print " ERROR.  See $build_dir/build.log for details.\n";
        	       	$script_status++;
				}
				else {
				
					# sym link to bin directory
					my $curr_dir = cwd();
			        opendir(CURR, $curr_dir) or die "ERROR: could not open directory: $curr_dir\n";
    	    		my @all_files = grep {! /^\./ } readdir CURR;
        			closedir(CURR);
					$exec_count = 0;
        			foreach $file (@all_files) {
						if (-f $file && -x $file) {
							unlink("$cwd/bin/$file") if (-l "$cwd/bin/$file");
							do_system("ln -s $cwd/$build_dir/$file $cwd/bin/$file");
							print "\n\t\t" if ($exec_count++ > 0);
							print " installing bin/$file...";
						}
        			}
					print " ok\n";
				}
				chdir($cwd);
			}
		}
	}
}

##############################################################################
sub init {

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
 		@run_modules = complement(\@modules,\@nonbuildmodules);
	}

	$time = (split(/ +/,localtime()))[3];

	# confirm all modules are checked out
	foreach my $dir (@run_modules) {
		next if defined($module2syslib{$dir});
		if (! -e $dir) { update($dir); }
	}

	# update makefiles in each module - do all before entering loop below
	# since this may be interactive
	foreach my $dir (@run_modules) {
		if (-e $dir) { 
			my $cwd = cwd();
			my @build_dirs = ($dir);
			if (defined($module2targets{$dir})){ # module has nested targets
				@build_dirs = @{$module2targets{$dir}};
			}
			foreach my $build_dir (@build_dirs) {
				chdir $build_dir; 
				if (-e "makefile.template") { # generate makefile
					print "\tcreating makefile in $build_dir...";
					fillin_makefile($build_dir);
					print " ok\n";
				}
				chdir $cwd;
			} 
		}
	}

	# need to sort modules based on dependencies
	my @tmp_modules = sort by_depend(@run_modules);
	print "($count) initializing: @tmp_modules, at $time\n";	

	foreach my $dir (@tmp_modules) {
		if (-e $dir) { 
			my $cwd = cwd();
			my @build_dirs = ($dir);
			if (defined($module2targets{$dir})){ # module has nested targets
				@build_dirs = @{$module2targets{$dir}};
			}
			foreach my $build_dir (@build_dirs) {
				chdir $build_dir; 
				if (-e "makefile.template") {

					# run "make init"
					if (!defined($up_to_date_modules{$build_dir})) {
						print "\tinitializing $build_dir...";
						do_system("make init > init.log 2>&1");
					
						# check for error status
               			if($? > 0) {
               				print " ERROR $?. See $build_dir/init.log for details.\n";
               				$script_status++;
               			}
						else { 
							print " ok\n"; 
							unlink(".status"); # remove flag
						}
					} else { unlink(".status"); } # remove flag
				}
		 		chdir $cwd;
			}
		}
	}
}

##############################################################################
sub clean {

	# double-check
	print "Are you sure you want to remove all objects and project settings (y/n) [n]: ";
	my $ans = <STDIN>;
	exit if ($ans !~ /y/);

	# run all unless specified
	my @run_modules = @_;
	if (scalar(@run_modules) == 0) {
		@run_modules = @modules;
	}

	$time = (split(/ +/,localtime()))[3];

	print "($count) cleaning: @modules, at $time\n";
	foreach $dir (@run_modules) {
		if (-e $dir) { 
			my $cwd = cwd();
			my @build_dirs = ($dir);
			if (defined($module2targets{$dir})){ # module has nested targets
				@build_dirs = @{$module2targets{$dir}};
			}
			foreach my $build_dir (@build_dirs) {
				chdir $build_dir; 
				if (-e "makefile.template") {
			
					# create makefile
					fillin_makefile($build_dir) if (! -e "makefile");
			
					print "\tcleaning $build_dir...";
					do_system("make clean > clean.log 2>&1");
					print " ok\n";
				
					# remove the makefile
					unlink("makefile");

					# remove module preferences
					unlink(".tahoe_config") if (-e ".tahoe_config");
		
					# flag
					do_system("echo 'init' > .status");
				}
		 		chdir $cwd;
			}
		}
	}

	# move configuration file
	print "moving .tahoe_config to tahoe_config.BAK\n";
	do_system("mv -f .tahoe_config tahoe_config.BAK");
	
	# clean out bin directory
	if (-e "bin") { do_system("rm bin/*"); }
}

##############################################################################
sub test{
	$time = (split(/ +/,localtime()))[3];
	print "($count) running tests at $time\n";
	my $cwd = cwd();
	chdir("benchmark_XML/comparator");
	print("\tbuilding comparator...");
	fillin_makefile("comparator"); do_system("make init build > build.log 2>&1");
	die "error building compare\n" if (! -x "compare");

	# sym link to bin directory
	unlink("$cwd/bin/compare") if (-l "$cwd/bin/compare");
	do_system("ln -s $cwd/benchmark_XML/comparator/compare $cwd/bin/compare");
	print " installing bin/compare...";
	
	print(" ok\n");
	chdir("$cwd/benchmark_XML");
	print("\tremoving previous results...");
	do_system("make clean > build.log 2>&1");
	print(" ok\n");
	print("\trunning benchmark cases...");
	do_system("$cwd/tahoe/tahoe -f run.batch > run.out 2>&1");
	print(" ok\n");
	print("\tcomparing benchmarks...");
	do_system("./comparator/compare -f run.batch > compare.out 2>&1");
	print(" ok\n");
	open(IN,"compare.summary") || die "could not open $cwd/compare.summary\n";
	<IN>; 
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $pass = $_;   
	$_ = <IN>; chomp(); s/^\s+//; s/\s+$//; $fail = $_;   
	print "* $pass,  $fail, see benchmark_XML/compare.summary for more details\n";
	while(<IN>) {
		if (/FAIL/) {print "* $_" ;}
	}
	close(IN);
}

##############################################################################
sub failed{
	$time = (split(/ +/,localtime()))[3];
	die "*-*-*-* process FAILED at $time *-*-*-*\n";
}

##############################################################################
sub usage {
	print "\nusage: tahoe-manager [list options]\n";
	print "       build   : builds modules (calls init if needed)\n";
	print "       config  : change build options\n";
	print "       update  : updates or checks out modules\n";
	print "   selfupdate  : updates this script\n";
	print "       init    : creates makefiles and initializes modules\n";
	print "       clean   : cleans modules\n";
	print "       test    : runs regression tests\n";
	print "\n";
	exit 1;
}

##############################################################################
sub a_depends_on_b {

	# needs two arguments
	if (scalar(@_) != 2) {
		print "a_depends_on_b: expecting 2 arguments\n";
	}
	my ($a, $b) = @_;

	# look for dependency in makefile
	my $source = "$a/makefile.template";
	if (-e $source) {
		open(IN, "$source");
		my @lines = <IN>; 
		close(IN);
		my $bdefine = $module2define{$b};
		foreach my $line (@lines) {
			return 1 if ($line =~ /^#?$bdefine/);
		}
	}
	return 0;
}

##############################################################################
sub by_depend {
	my $rank_a = -1;
	my $rank_b = -1;
	my $rank = 0;
	MOD: foreach my $module (@modulebydepend) {
		if ($module eq $a) { $rank_a = $rank; }
		elsif ($module eq $b) { $rank_b = $rank; }
		last MOD if ($rank_a != -1 && $rank_b != -1);
		$rank++;
	}

	my $comp = ($rank_a <=> $rank_b);
	#print " $a ($rank_a) $b ($rank_b) : $comp\n";
	return $comp;	
}

##############################################################################
sub fillin_makefile{

	# working directory
	my $dir = shift(@_);

	# no config file in this module
	my $mod_arch = $arch;	
	if (! -e ".tahoe_config") {
		if( $use_default_arch =~ /false/i ) {
		print " use default ARCH = $mod_arch (y/n) [y]: ";
		$ans = <STDIN>;
		chomp($ans);
		if (length($ans) > 0 && $ans !~ /y/i) {
			my $path = cwd();
			chdir($tahoe_home);
			$mod_arch = get_arch();
			chdir($path);
		}
		}
		print "...";

		# write module config file
		open (ARCH, ">.tahoe_config") || die "could not open .tahoe_config\n";
		print ARCH "$mod_arch\n";
		close (ARCH);
	}
	
	# read the arch 
	open (ARCH, ".tahoe_config") || die "could not open .tahoe_config\n";
	$mod_arch = <ARCH>;
	close(ARCH);
	chomp($mod_arch);

	# if makefile exists, preserve MOD_ macros in makefile
	my %mod_macros = qw(
		MOD_CFLAGS_C 0
		MOD_CFLAGS_CC 0
		MOD_CFLAGS_F 0
		MOD_LFLAGS 0
	);
	my @mod_macros_keys = ();
	if (-e "makefile") { # collect MOD_ macro definitions
		open(IN, "makefile");
		@mod_macros_keys = keys(%mod_macros);
		while (defined($line = <IN>)) {
			foreach my $key (@mod_macros_keys) {
				if ($line =~ /^$key\s*=/) {
					$mod_macros{$key} = $line;
				}
			}
		}
		close (IN);
	}

	unlink("makefile");
	my $path = cwd();
	open(IN,"makefile.template");
	open(OUT,">makefile");
	print OUT "################################################################################\n";
	print OUT "#### NOTE: This makefile is automatically generated from makefile.template. ####\n";
	print OUT "####       Changes to the MOD_ macros are preserved. All other changes will ####\n";
	print OUT "####       be lost.                                                         ####\n";
	print OUT "################################################################################\n\n";
	while (defined(my $line = <IN>)){
	
		# configuration
		$line =~ s/^HOME_DIR =/HOME_DIR = $path/;
		$line =~ s/^ARCH =/ARCH = $mod_arch/;
		
		# restore MOD_ macros
		foreach my $key (@mod_macros_keys) {
			if ($line =~ /^$key\s*=/) {
				$line = $mod_macros{$key};
			}
		}
		
		# optional modules
		foreach my $module (@modules) {
			my $define = $module2define{$module};
			$line =~ s/\#$define/$define/;
		}

		# UP_TO_DATE modules - tahoe module only
		if ($dir eq "tahoe" && $line =~ /UP_TO_DATE\ =\ NONE/) {
			$up_to_date = "";
			foreach $module (@modules) {
				if (defined($up_to_date_modules{$module})) {
					$up_to_date = $up_to_date." \$(".$module2define{$module}."DIR)";
				}
			}
			if (length($up_to_date) > 0) {
				$line =~ s/=\ NONE/=$up_to_date/;
			}
		}
		
		print OUT "$line";
 	}
	close(IN);
	close(OUT);
}

##############################################################################
sub write_config {
	open(CONFIG,">$config_file") || die "cannot open file $config_file for writing : $!";
	#print CONFIG  "# TAHOE_LOGIN\n$tahoe_name\n\n";
	print CONFIG  "# TAHOE_SF_LOGIN\n$tahoe_sf_name\n\n";
	#print CONFIG  "# TAHOE_CO_LOGIN\n$tahoe_co_name\n\n";
	print CONFIG  "# TAHOE_CLD_LOGIN\n$tahoe_cld_name\n\n";
	print CONFIG  "# CONNECTION\n$connection\n\n";
	print CONFIG  "# PROXY\n$proxy\n\n";
	print CONFIG  "# ARCHITECTURE\n$arch\n\n";
	print CONFIG  "# USE_DEFAULT\n$use_default_arch\n\n";
	print CONFIG  "# MODULES\n@modules\n\n";
	print CONFIG  "# VERBOSE\n$verbose\n\n";
	print CONFIG  "# TAHOE_HOME\n$tahoe_home\n\n";
	print CONFIG  "# EOF";
	close(CONFIG);
}

##############################################################################
sub config_optional_modules {

	# private modules on Tahoe server
	my @myoptionalmodules = ();
	if ($tahoe_name !~ /NONE/) {
		@myoptionalmodules = @optionalmodules;
	} else { # filter out
		foreach my $module (@optionalmodules) {
			push (@myoptionalmodules, $module) if ($module2repo{$module} !~ /$tahoe/);
		}
	}

	# collect current status of optional modules
	my @opt_mod_off = complement(\@myoptionalmodules, \@modules);	
	my @status = ();
	foreach my $module (@myoptionalmodules) {
		my @tmp = ($module);
		my @inter = intersection(\@opt_mod_off, \@tmp);
		if (scalar(@inter) == 1) {
			push(@status, "OFF");
		} else {
			push(@status, " ON");		
		}
	}

	# prompt for changes
	my @oldstatus = @status;
	my $done = 0;
	while ($done == 0) {
		print "\nOptional modules:\n";
		my $i = 0;
		while ($i < scalar(@myoptionalmodules)) {
			print " " if ($i < 10);
			print "$i $status[$i] $myoptionalmodules[$i]\n";
			$i++;
		}
		print "\n";
		print " " if ($i < 10);
		print "$i Toggle all modules ON\n"; $i++;
		print " " if ($i < 10);
		print "$i Toggle all modules OFF\n"; $i++;
		print " " if ($i < 10);
		print "$i Exit\n"; $i++;
		print "\nChoice or modules to toggle (applied left to right): ";
		my $ans = <STDIN>;
		chomp($ans);
		my @opts = split(/ +|,/, $ans);
		foreach $ans (@opts) {
			if ($ans == scalar(@status)) { # all ON
				my $i = 0;
				while ($i < scalar(@status)) {
					$status[$i] = " ON";
					$i++;
				}
			}
			elsif ($ans == scalar(@status)+1) { # all OFF
				my $i = 0;
				while ($i < scalar(@status)) {
					$status[$i] = "OFF";
					$i++;
				}
			}
			elsif ($ans == scalar(@status)+2) { # all Exit
				$done = 1;
			} else { # toggle option
				if ($status[$ans] eq "OFF") {
					$status[$ans] = " ON";
				} else {
					$status[$ans] = "OFF";				
				}
			}
		}
	}

	# process changes to modules
	my @addmodules = ();
	@modules = @defaultmodules; # reset
	my $i = 0;
	while ($i < scalar(@myoptionalmodules)) {
		my $module = $myoptionalmodules[$i];
		if ($status[$i] eq " ON") {
			push(@modules, $module);
			push(@addmodules, $module) if ($oldstatus[$i] eq "OFF");
			update($module) if (! -d $module && !defined($module2syslib{$module})); # fetch new modules to determine dependencies
		}
		$i++;
	}

	# look for other modules that must/may be included
	$done = 0;
	while ($done == 0) {

		# add any additional required modules
		my @missing_required = get_missing_modules();
		if (scalar(@missing_required) > 0) {
			print "adding required modules: @missing_required\n";
			foreach my $mod (@missing_required) {
				push(@addmodule, $mod);
				push(@modules, $mod);
				update($mod) if (! -d $mod && !defined($module2syslib{$mod})); # fetch new modules to determine dependencies
			}
			@opt_mod_off = complement(\@myoptionalmodules, \@modules);
		}
	
		# optional modules not included
		my @missingmodules = complement(\@opt_mod_off, \@addmodules);
		my @dependmodules = ();
		foreach $missingmodule (@missingmodules) { # missing module needed due to dependency
			DEP: foreach $addmodule (@addmodules) {
				if (a_depends_on_b($addmodule, $missingmodule) == 1) {
				
					#print "opt: $addmodule extended by $missingmodule\n";
				
					push (@dependmodules, $missingmodule);
					last DEP;
				}
			}
		}

		# add dependent modules
		if (scalar(@dependmodules) > 0) {
			print "the newly added modules can be extended with optional modules: @dependmodules\n";
			print "add optional modules (y/n) [y]: ";
			my $ans = <STDIN>;
			if ($ans !~ /n/i) {
				foreach $module (@dependmodules) {
					push (@addmodules, $module);
					push (@modules, $module);
					update($module) if (! -d $module); # fetch new modules to determine dependencies
				}
				@opt_mod_off = complement(\@myoptionalmodules, \@modules);
			} else { $done = 1; }
		} else { $done = 1; }
	}	

	# collect current final status of optional modules
	@opt_mod_off = complement(\@myoptionalmodules, \@modules);	
	@status = ();
	foreach my $module (@myoptionalmodules) {
		my @tmp = ($module);
		my @inter = intersection(\@opt_mod_off, \@tmp);
		if (scalar(@inter) == 1) {
			push(@status, "OFF");
		} else {
			push(@status, " ON");		
		}
	}

	# collect list of settings that have changed
	my @changedmodules = ();
	my $j = 0;
	while ($j < scalar(@myoptionalmodules)) {
		push(@changedmodules, $myoptionalmodules[$j]) if ($status[$j] ne $oldstatus[$j]);
		$j++;
	}

	# flag modules that need to be re-initialized
	foreach my $module (@modules) {
		foreach my $changedmodule (@changedmodules) {
			if (a_depends_on_b($module, $changedmodule) == 1) {
				do_system("echo 'init' > $module/.status");
			}
			
			# "touch" target
			if (-e "$module/makefile.template" && defined($module2touch{$changedmodule})) {
				my $cwd = cwd();
				chdir($module);
				
				# generate makefile
				if (! -e "makefile") {
					print "\tcreating makefile in $module...";
					fillin_makefile($module);
					print " ok\n";
				}
								
				# touch
				do_system("make $module2touch{$changedmodule} >> build.log 2>&1");
				chdir $cwd;
			}
		}
	}

	print "* modules : @modules \n";
	return 1;
}

##############################################################################
sub add_optional_modules {

	# collect optional modules not currently included
	my @newoptionalmodules = complement(\@optionalmodules, \@modules);	
	if (scalar(@newoptionalmodules) == 0) {
		print "\n* all optional modules already included\n\n";
		return 0;
	}

	# select modules to add
	print "\noptional modules:\n";
	my $i = 0;
	foreach my $choice (@newoptionalmodules) { 
		print "$i $choice\n"; 
		$i++;
	}
	print "\nmodule numbers to add: "; 
	my $choice = <STDIN>; 
	chomp($choice);
	my @choices = split(/ +|,/,$choice);
	my @addmodules = ();
	foreach my $choice (@choices) {
		$choice = $newoptionalmodules[$choice];
		push (@addmodules, $choice);
		push (@modules, $choice);
		update ($choice) if (! -d $choice);
	}

	# look for other modules that must/may be included
	my $done = 0;
	while ($done == 0) {

		# add any additional required modules
		my @missing_required = get_missing_modules();
		if (scalar(@missing_required) > 0) {
			print "adding required modules: @missing_required\n";
			foreach my $mod (@missing_required) {
				push(@addmodule, $mod);
				push(@modules, $mod);
				update($mod) if (! -d $mod); # fetch new modules to determine dependencies
			}
			@newoptionalmodules = complement(\@optionalmodules, \@modules);
		}
	
		# optional modules not included
		my @missingmodules = complement(\@newoptionalmodules, \@addmodules);
		my @dependmodules = ();
		foreach $missingmodule (@missingmodules) { # missing module needed due to dependency
			DEP: foreach $addmodule (@addmodules) {
				if (a_depends_on_b($addmodule, $missingmodule) == 1) {
					push (@dependmodules, $missingmodule);
					last DEP;
				}
			}
		}

		# add dependent modules
		if (scalar(@dependmodules) > 0) {
			print "the newly added modules can be extended with optional modules: @dependmodules\n";
			print "add optional modules (y/n) [y]: ";
			my $ans = <STDIN>;
			if ($ans !~ /n/i) {
				foreach $module (@dependmodules) {
					push (@addmodules, $module);
					push (@modules, $module);
					update($module) if (! -d $module); # fetch new modules to determine dependencies
				}
				@newoptionalmodules = complement(\@optionalmodules, \@modules);
			} else { $done = 1; }
		} else { $done = 1; }
	}	

	# flag modules that need to be re-initialized
	foreach my $module (@modules) {
		foreach my $addmodule (@addmodules) {
			if (a_depends_on_b($module, $addmodule) == 1) {
				do_system("echo 'init' > $module/.status");
			}
			
			# "touch" target
			if (-e "$module/makefile" && defined($module2touch{$addmodule})) {
				my $cwd = cwd();
				chdir $module;
				do_system("make $module2touch{$addmodule} >> build.log 2>&1");
				chdir $cwd;
			}
		}
	}

	print "* modules : @modules \n";
	return 1;
}

##############################################################################
sub remove_optional_modules {

	# collect optional modules currently included
	my @curr_optionalmodules = intersection(\@optionalmodules, \@modules);
	if (scalar(@curr_optionalmodules) == 0) {
		print "\n* no optional modules included\n\n";
		return 0;
	}
	
	# select modules to remove
	print "\noptional modules:\n";
	my $i=0;
	foreach my $choice (@curr_optionalmodules) { 
		print "$i $choice\n"; 
		$i++;
	}
	print "\nmodule numbers to remove: "; 
	$choice = <STDIN>; 
	chomp($choice);
	my @choices = split(/ +|,/,$choice);

	# flag modules that need to be re-initialized
	foreach my $module (@modules) {
		foreach $choice (@choices) {
			my $outmodule = $curr_optionalmodules[$choice];
			if (a_depends_on_b($module, $outmodule) == 1) {
				do_system("echo 'init' > $module/.status");
			}

			# "touch" target
			if (-e "$module/makefile" && defined($module2touch{$outmodule})) {
				my $cwd = cwd();
				chdir($module);
				do_system("make $module2touch{$outmodule} >> build.log 2>&1");
				chdir($cwd);
			}
		}
	}

	# rebuild modules list
	foreach $choice (@choices) {
		my @modules_tmp = @modules;
		@modules = ();
		foreach $module (@modules_tmp) {
			if ($module cmp $curr_optionalmodules[$choice]) {
				push(@modules, $module);
			}
		}
	}
	print "* modules : @modules \n";
	return 1;
}

##############################################################################
sub module_config {

	# buildable modules
	my @run_modules = complement(\@modules,\@nonbuildmodules);

	# collect list of configurable modules
	my @config_modules = ();
	foreach my $module (@run_modules) {
	
		# check out if not present
		update($module) if (! -e $module && ! defined($module2syslib{$module}));
	
		# look for config files
		if (-d "$module/config") {
			open(CHECK, "ls -1 $module/config | grep -c \.conf |");
			my $count = <CHECK>;
			chomp($count);
			close(CHECK);
			if ($count > 0) {
				push(@config_modules, $module);
			}
		}
	}
	
	if (scalar(@config_modules) == 0) {
		print "* there are no modules with configurable options\n\n";
		return 0;
	}
	else {
		print "\nconfigurable modules:\n";
		my $i=0;
		foreach my $choice (@config_modules) { 
			print "$i $choice\n"; 
			$i++;
		}
		my $change = 0;
		print "\nmodules to configure: ";
		$choice = <STDIN>; 
		chomp($choice);				
		my @choices = split(/ +|,/,$choice);
		foreach $choice (@choices) {	
			$change += configure_module($config_modules[$choice]);
		}
		return $change;
	}
}

##############################################################################
sub configure_module {
	my $module = shift(@_);
	
	# regenerate the configuration headers
	my $cwd = cwd();
	chdir $module;
	fillin_makefile($module);
	do_system("make update_config > build.log 2>&1");
	
	# find configuration headers
	@config_headers = ();
	open(LS, "ls -1 src-mirror/config |");
	while (defined($file = <LS>)) {
		chomp($file);
		if ($file =~ /\.h$/) {
			push(@config_headers, $file);
		}
	}

	my $change = 0;
	if (scalar(@config_headers) == 0) {
		print "\n* there are no headers with configurable options\n\n";	
	} else {
		print "\nconfigurable headers in module $module:\n";
		$i=0;
		foreach my $choice (@config_headers) { 
			print "$i $choice\n"; 
			$i++;
		}	print "\nheaders to configure: ";
		$choice = <STDIN>; 
		chomp($choice);
		my @choices = split(/ +|,/,$choice);
		foreach $choice (@choices) {	
			if (configure_header($config_headers[$choice]) != 0) {
				do_system("echo 'init' > .status");
				$change++;
			}
		}
	}

	# back
	chdir $cwd;
	return $change;
}

##############################################################################
sub configure_header {
	my $header = shift(@_);
	
	# read header info
	my @info = ();
	my @status = ();
	my @symbol = ();
	open(IN, "src-mirror/config/$header") || die "could not open \"$header\"\n";
	my $flag = 0;
	my $max_len = 0;
	while (defined(my $line = <IN>)) {
		if ($flag == 0) {
			$flag = 1 if ($line =~ /\\def [a-zA-Z0-9_-]/);
		} elsif ($flag == 1) { # description
			chomp($line);
			$line =~ s/( \* )(.*)/$2/;
			push(@info, $line);
			$flag = 2;
		} elsif ($flag == 2) {

			# forward to #define line			
			while ($line !~ /^[\/\* ]*#define/) { $line = <IN>; }
		
			# status
			chomp($line);
			if ($line =~ /^#define/) {
				push(@status, " ON");
			} else {
				push(@status, "OFF");			
			}
			
			# symbol
			$line =~ s/(.*#define )([a-zA-Z0-9_-]+)(.*)/$2/;
			push(@symbol, $line);
			$max_len = length($line) if (length($line) > $max_len);
			$flag = 0;
		}
	
	}
	close(IN);

	# prompt for changes
	my @oldstatus = @status;
	my $done = 0;
	while ($done == 0) {
		print "\nOptions:\n";
		my $i = 0;
		while ($i < scalar(@symbol)) {
			print " " if ($i < 10);
			my $line = "$i $status[$i] $symbol[$i]";
			my $j = 0;
			while ($j < $max_len - length($symbol[$i])) {
				$line = $line." ";
				$j++;
			}
			$line = $line." $info[$i]\n";
			print $line;
			$i++;
		}
		print "\n";
		print " " if ($i < 10);
		print "$i Toggle all options ON\n"; $i++;
		print " " if ($i < 10);
		print "$i Toggle all options OFF\n"; $i++;
		print " " if ($i < 10);
		print "$i Exit\n"; $i++;
		print "\nChoice or options to toggle (applied left to right): ";
		my $ans = <STDIN>;
		chomp($ans);
		my @opts = split(/ +|,/, $ans);
		foreach $ans (@opts) {
			if ($ans == scalar(@status)) { # all ON
				my $i = 0;
				while ($i < scalar(@status)) {
					$status[$i] = " ON";
					$i++;
				}
			}
			elsif ($ans == scalar(@status)+1) { # all OFF
				my $i = 0;
				while ($i < scalar(@status)) {
					$status[$i] = "OFF";
					$i++;
				}
			}
			elsif ($ans == scalar(@status)+2) { # all Exit
				$done = 1;
			} else { # toggle option
				if ($status[$ans] =~ "OFF") {
					$status[$ans] = " ON";
				} else {
					$status[$ans] = "OFF";				
				}
			}
		}
	}
		
	# write new header
	open(IN, "src-mirror/config/$header") || die "could not open $header\n";
	@file = <IN>;
	close(IN);
	open(OUT, ">src-mirror/config/$header") || die "could not open $header\n";
	my $count = -1;
	foreach my $line (@file) {
		if ($line =~ /^[\/\* ]+#define|^#define/) {
			if ($count > -1) { # skip #define at top of file
				$line = "";
				$line = $line."//" if ($status[$count] =~ "OFF");
				$line = $line."#define $symbol[$count] 1\n";
			}
			$count++;
		}
		print OUT $line;
	}
	close(OUT);
	
	# count changes
	my $changes = 0;
	my $i = 0; 
	while ($i < scalar(@status)) {
		$changes++ if ($status[$i] !~ $oldstatus[$i]);
		$i++
	}

	return $changes;
}

##############################################################################
sub print_in_columns {
	my $cols = shift(@_);
	my @choices = @_;
	
	# find longest name
	my $max_len = 0;
	my $choice;
	foreach $choice (@choices) {
		if (length($choice) > $max_len) { $max_len = length($choice); }
	}
	my $col_width = $max_len + 3 + 10; # 3 for item number and gap
	my $num_values = scalar(@choices);
	my $jump = int($num_values/($cols))+1;
	my $i = 0;
	while ($i < $jump) {
		my $line = "";
		my $col = 0;
		my $ii = $i;
		while ($col < $cols) {
			my $col_i = "";
			if ($ii < 10) { $col_i = $col_i." "; }
			if ($ii < $num_values) { $col_i = $col_i.$ii." $choices[$ii]"; }
			while ($col != $cols-1 && length($col_i) < $col_width) { $col_i = $col_i." "; }
			$col++;
			$ii += $jump;
			$line = $line.$col_i;
		}
		print "$line\n";
		$i++;
	}
}

##############################################################################
sub get_arch {
	my $cwd = cwd();
	chdir "macros"; 
	my @macros = glob("*.macros"); 
	my @choices = ();
	foreach my $choice (@macros) { 
		$choice =~ s/\.macros//; 
		push(@choices,$choice);
	}
	chdir $cwd;
	print "no default build architecture, choices (".scalar(@choices)."):\n";
	my $i=0;	
	print_in_columns(3, @choices);
	print "\ndefault build architecture number: "; 
	$i = <STDIN>; 
	my $arch = $choices[$i]; 
	print "* you chose : $arch\n";
	return $arch;
}

##############################################################################
sub get_missing_modules {

	# collect omitted modules
	my @allmodules = sort(keys(%module2define));
	my @missing_modules = complement(\@allmodules, \@modules);

	# collect missing, required
	@req_missing = ();
	foreach my $dir (@modules) {
		my $filename = "$dir/makefile.template";
		if (-e $filename) {
			open(IN,"$filename");
			my @lines = <IN>; 
			close(IN);
			foreach my $mod (@missing_modules) {
				my $define = $module2define{$mod};
				
				# add if not already in the list
				SEARCH : foreach my $line (@lines) {
					if ($line =~ /^$define/) {
						my @tmp = ($mod);
						push(@req_missing, $mod) if (scalar(intersection(\@req_missing, \@tmp)) == 0);
						last SEARCH;
					}				
				}
			}
		}
	}
	return @req_missing;
}

##############################################################################
# return the values in the first list that do not appear in the second
##############################################################################
sub complement {
	my ($all, $some) = @_;
	my @complement = ();
	foreach my $all_i (@$all) {
		my $found = 0;
		LOOK: foreach my $some_i (@$some) {
			if ($some_i eq $all_i) {
				$found = 1;
				last LOOK;
			}
		}
		push(@complement, $all_i) if ($found == 0);
	}
	return @complement;
}

##############################################################################
sub intersection {
	my ($all, $some) = @_;
	my @complement = ();
	foreach my $all_i (@$all) {
		LOOK: foreach my $some_i (@$some) {
			if ($some_i eq $all_i) {
				push(@complement, $all_i);
				last LOOK;
			}
		}
	}
	return @complement;
}

##############################################################################
sub findENV {
	foreach my $key (sort(keys %ENV)) {
        	if ($key eq $_[0]) {return $ENV{$key}; }       
	}
	return undef;
}

##############################################################################
sub do_system {

	# execute system command
	$cmd = shift(@_);
	system($cmd);
	
	# trap SIGINT - cvs catches SIGINT and then signals 256
	#print "\n $?: $cmd\n";
	if ($? == 2 || ($cmd =~ /^cvs/ && $? == 256)) {
		print "\ninterrupted.\n";
		exit;
	}
}
