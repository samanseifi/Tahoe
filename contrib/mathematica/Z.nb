(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.0'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[     50481,       1782]*)
(*NotebookOutlinePosition[     51329,       1811]*)
(*  CellTagsIndexPosition[     51285,       1807]*)
(*WindowFrame->Normal*)



Notebook[{
Cell[" $Id: Z.nb,v 1.2 2008/07/20 23:31:46 paklein Exp $", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["Documentation:", "Subsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "How the Z's work:\n\nThe strategy is to identify all subexpressions with a \
",
  StyleBox["Depth",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " less than 2 (",
  StyleBox["ParseCommon",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ").  Some of these subexpressions will have a ",
  StyleBox["Length",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " greater than 2, which means there may be some common sub-subexpressions \
(",
  StyleBox["CommonTermsOne",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ", ",
  StyleBox["CommonTermsAll",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ").  ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'s are chosen from the list of subexpressions with ",
  StyleBox["Depth",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " less than 2 and greater than 1 (no atoms).  The expression is then \
evaluated with the sub-expressions replaced with the ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'s and the function (",
  StyleBox["ToZ",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ") is recursively applied until the final expression appears the same as \
its ",
  StyleBox["ParseCommon",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " result."
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "Dealing with ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements:\n\nThere are (at least) 2 issues that arise when tryting to \
apply the ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'s to ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements.\n\n(1) ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " has the ",
  StyleBox["HoldAll",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " attribute\n(2) The conditional expression in the ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statement should not be ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'d\n\n(1) ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " must be ",
  StyleBox["HoldAll",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " because the there my by improper expressions in the branches of the \
statement that should not be evaluated if the condition does not apply, ie:\n\
\n",
  StyleBox["If[Length[a] >= 2, a[[2]], 0]\n\n",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "If ",
  StyleBox["a",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " is not a ",
  StyleBox["List",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " then part 2 of ",
  StyleBox["a",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " will not exist and cannot be evaluated.  The difficulty arises with the \
",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'s when trying to eliminate common subexpressions from the branches of the \
",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements, as well as from the conditional expression.  The \
sub-expressions returned by ",
  StyleBox["ParseCommon",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " will not in general be the same as the unevaluated forms.  The solution \
is to cause all arguments of the ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements to be evaluated (just once for now).   Evaluation occurs in ",
  StyleBox["ToZ",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " which then passes the result onto ",
  StyleBox["ToZShell",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " for the sub-expression elimination.  It may be necessary to re-evaluate \
all the arguments in the ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements during the ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "-ing process to allow continued elimintation of subexpressions, but this \
question is still under investigation.  If the routines enter an infinite \
loop when trying to ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " an expression containing complicated ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements, the likely solution will be to force evaluation of the \
arguments again after some sub-expressions have been eliminated.\n\n(2) In \
general, the conditional expression in an ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements would be ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'s like any other.  For C/C++ and \"if\" statement is false if, and only \
if, the the condition returns integer(0), which may be difficult or \
unreliable if cast from a double precision ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ".  Therefore, the conditional statement should not be ",
  StyleBox["z",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "'d.  This filtering of conditional statements is achieved by eliminating \
conditional statements with a ",
  StyleBox["Depth",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " of 2 (that is, where each argument is a simple expression) from the \
sub-expressions returned by ",
  StyleBox["ParseCommon",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ", and allowing entire ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " statements to be treated as a single sub-expression if each of the \
arguments has a ",
  StyleBox["Depth",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " of 2 or less.\n\nKnown issues:\n(1) when generating Fortran output, the \
formatter uses the double-precision versions of the intrinsic math functions. \
When these are called with a single numerical argument, the compiler may \
complain the argument type is incorrect because ",
  StyleBox["sqrt(3.)", "Input"],
  " should be ",
  StyleBox["sqrt(3.d0)", "Input"],
  " because floating point numbers are not output in the fortran \
double-precision format.\n(2) in expressions involving ",
  StyleBox["If", "Input"],
  "statements, both branching of the statement are evaluated before the test \
is evaluated, meaning both branches must produce valid results under all \
circumstances."
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Set evaluation options:", "Subsection"],

Cell[BoxData[{
    \(\(Off[General::spell];\)\), "\[IndentingNewLine]", 
    \(\(Off[General::spell1];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["ToZ:", "Subsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["User functions:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ToZ[rawexpr_, z_Symbol, nz_Integer, opts___] := Module[ 

\t{nz2,parse,copy,rules,n,i,zstr, znstr,temp,newrule,Parseopt,Verboseopt,
\t Defaults, expr, nextparse},
\t
\tIfattributes = Attributes[If];
\tMap[ClearAttributes[If, #]&, Ifattributes];
\texpr = rawexpr /. If[_,0,0] -> 0;
\tMap[SetAttributes[If, #]&, Ifattributes];

\t(* Default options *)
\tDefaults = {Parse -> One, Verbose -> True};
\tParseopt = Parse /. {opts} /. Defaults;
\tVerboseopt = Verbose /. {opts} /. Defaults;
\t
\tnz2 = nz;
\trules = {};
\tzstr = ToString[z];

(*\tPrint[\"depth = \",Depth[expr]]; *)
\tparse = ParseCommon[expr,Parseopt];

(*\tPrint[\"expr  = \", expr];
\tPrint[\"parse = \", parse];
\tPrint[\"fl    = \", Union[Flatten[{expr}]]]; *)

\tIf[ !SameQ[parse,Union[Flatten[{expr}]]] || Max[Map[Depth, parse]] > 1,
(*\tIf[ !SameQ[parse,RemoveRepeats[expr]],\t *)
(*\tIf[ !SameQ[parse,Sort[Flatten[{expr}]]], *)
\t
\t\t(* parse = Join[Select[parse,ZNumberQ],Select[parse, Depth[#] > 1 &]]; *)
\t\tparse = Select[parse, Depth[#] > 1 &];

\t\tn = Length[parse];\t
\t\tWhile[ n > 0,
\t\t
\t\t\t\t(* didn't make much difference *)
\t\t\t\t(* parse = Sort[parse, (Length[#1] < Length[#2])&]; *)
\t\t\t
\t\t\t\tparse = Sort[parse];
\t\t\t\t
\t\t\t\tnz2++;
\t\t\t\tznstr = StringJoin[zstr,ToString[nz2]];
\t\t\t\tIf[Mod[nz2,1000]==0,
\t\t\t\tPrint[\"Z count = \",nz2]
\t\t\t\t];
\t\t\t\t
\t\t\t\tnextparse = parse[[1]];
\t\t\t\t
\t\t\t\t(* limit length of expressions *)
\t\t\t\tIf[ (Head[nextparse] === Times || Head[nextparse] === Plus) && 
\t\t\t\t\tLength[nextparse] > ZLengthLimit,
\t\t\t\t\tnextparse = Take[nextparse, ZLengthLimit]]; 
\t\t\t\t
\t\t\t\tnewrule = nextparse -> ToExpression[znstr];
\t\t\t\trules = Append[rules, newrule];
\t\t\t\tIf[Verboseopt,
\t\t\t\t\t(* Print[zstr, nz2,\" = \", InputForm[nextparse],\";\"]; *)
\t\t\t\t\t(* PrintRule[OutputFormat][newrule]; *)
\t\t\t\t\tPrint[newrule]
\t\t\t\t];
\t\t\t
\t\t\t\tparse = parse /. newrule;
\t\t\t
\t\t\t\t(* find new commmon sub-expressions *)
\t\t\t\t(*
\t\t\t\tIf[SameQ[Parseopt,All],
\t\t\t\tparse = Union[parse,ParseCommon[Select[parse,(Length[#] > \
2)&],Parseopt]];
\t\t\t\t\t];
\t\t\t\t*)
\t\t\t\t
\t\t\t\t(* parse = Join[Select[parse,ZNumberQ],Select[parse, Depth[#] > 1 \
&]]; *)
\t\t\t\tparse = Select[parse, Depth[#] > 1 &];
\t\t\t\t\t\t\t\t
\t\t\t\tn = Length[parse]
\t\t\t\t];
\t\t
\t\t
\t\t(* recursion *)
\t\ttemp  = ToZ[expr //. rules, z, nz2, opts];
\t\tcopy  = temp[[1]];
\t\trules = Join[rules, temp[[2]]];
\t\tnz2   = temp[[3]],
\t\t
\t\tcopy = expr;
\t\tIf[Verboseopt,
\t\t\tPrint[copy];
\t\t\tPrintZ[z, nz2]
\t\t\t]
\t\t];
\t\t
\t{copy, rules, nz2}
\t
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ToZ[expr_,z_Symbol] := ToZ[expr,z,0];
ToZ[expr_] := ToZ[expr,z];
ToZ[expr_,opts___] := ToZ[expr,z,0,opts];
ToZ[expr_,z_Symbol,opts___] := ToZ[expr,z,0,opts];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Utilities:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["ZLengthLimit = 10;", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["rules to clean up expressions with ", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["NegativeQ[n_] := n < 0", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
HoldPower[z_, n_, d_] := HoldForm[Power[Power[z, \
Rational[n,d]],-1]]\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
HoldProduct[z_, n_, d_] := HoldForm[Times[-1, Times[Rational[n,d], \
z]]]\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
RationalPowerRule = Power[z_, Rational[n_?NegativeQ,d_]] :> \
HoldPower[z, -n, d];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
RationalProductRule = Times[Rational[n_?NegativeQ,d_], z_] :> \
HoldProduct[z, -n, d];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
CheckName[z_:z,n_] := Module[ {i, expr, zstr, istr, zname, none},

\tzstr = ToString[z];
\tnone = True;\t

\tDo[
\t\tistr = ToString[i];
\t\tzname = StringJoin[zstr,istr];
\t\texpr = ToExpression[zname];
\t\tIf[ !SameQ[zname,ToString[expr]],
\t\t\tnone = False;
\t\t\tPrint[zname,\" = \",expr]]
\t\t, {i,n}];
\t\t
\tIf[ none, Print[\"OK\"]]
\t\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ClearName[z_:z,n_] := Module[ {i, zstr, istr},

\tzstr = ToString[z];
\t
\tDo[
\t\tistr = ToString[i];
\t\tClear[Evaluate[StringJoin[zstr,istr]]]
\t\t, {i,n}]
\t\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
PrintZ[z_,n_,num_:12] := Module[ {i,str,zstr,prnt},

\tIf[n > 0,
\tzstr = ToString[z];
\tstr = \"{\";
\t
\tDo[
\t\tstr = StringJoin[str, zstr, ToString[i],\", \"];
\t\tIf[ Mod[i,num] == 0 && i != n,
\t\t\tPrint[str];
\t\t\tstr = \"\"
\t\t\t]
\t\t
\t\t,{i,n}];
\t\t
\tstr = StringJoin[StringTake[str,
\t\t\t\t\t\tMax[StringLength[str]-2,0]],\"}\"];

\tPrint[str]
\t]
];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["To skip 1 and 0:", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["ZNumberQ[x_] := (Head[x] == Real) && (x != 0) && (x != 1);", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Recursive parsing functions: ", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "Find common terms with the same ",
  StyleBox["Head",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " in the given ",
  StyleBox["List",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ":"
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
CommonTermsAll[list_,head_] := Module[ 

\t{temp1},
\t\t
\tIf[ SameQ[Head[list],List],
\t\ttemp1 = Select[list, (Depth[#] > 1 && Head[#] == head) &];
\t\ttemp1 = Flatten[Outer[Intersection,temp1,temp1]];
\t\tComplement[temp1,list],
\t\t{}]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
CommonTermsOne[list_,head_] := Module[ 

\t{temp2, temp1, n, terms, n1, n2},
\t\t
\tIf[ SameQ[Head[list],List],
\t\ttemp1 = Select[list, (Depth[#] > 1 && Head[#] == head) &];
\t\tn = Length[temp1];
\t\t
\t\tterms = {};
\t\t
\t\tFor[ n1 = 1, n1 <= n, n1++,
\t\t\tFor[ n2 = n1 + 1, n2 <= n, n2++,
\t\t\t\ttemp2 = Complement[{Intersection[temp1[[n1]],temp1[[n2]]]},list];
\t\t\t\tterms = Join[terms,temp2];
\t\t\t\t
\t\t\t\tIf[ Length[temp2] > 0 && 
\t\t\t\t\tDepth[temp2[[1]]] < 3 && Length[temp2[[1]]] < 3,
\t\t\t\t\tn1 = n2 = n] 
\t\t\t\t]
\t\t\t];
\t\t
\t\tterms ,
\t\t{}]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "Remove elements from ",
  StyleBox["list",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " after ",
  StyleBox["i",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " that contain ",
  StyleBox["list[[i]]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ":"
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["Parse driver.  Roughly 10x faster than before.", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
Parse[expr_] := If[Depth[expr] > 2,
\tUnion[Flatten[Map[ If[Depth[#] > 2, Parse[#], #]&,  Apply[List,expr] ]]],
\t\t{expr}];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "special ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " handling:"
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
Parse[If[x_,y__]] := If[ Max[Map[Depth,{x,y}]] > 2,
\t\t\t\t\t\t\t\tParse[{x,y}],
\t\t\t\t\t\t\t\t{If[x,y]}];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["Parse[{}] := {};", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  "Old version that's ",
  StyleBox["If",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "-compliant."
}], "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
Parse[expr_,res_:{}] := Module[ 

\t{n, i, j , res2, restemp, lres, temp1, temp2},

\tres2 = res;

\tIf[ !SameQ[Head[expr], If],

\t\tn = Length[expr];
\t
\t\tIf[Depth[expr] > 2,
\t\t\t
\t\t\tDo[ res2 = Parse[expr[[i]],res2],
\t\t\t\t{i,n}],

\t\t\tres2 = Union[res2,Flatten[{expr}]]
\t\t
\t\t\t]
\t,
\t(* else *)

\t(* special treatment for \"if's\" *)
\t\tIf[ Depth[ expr[[1]] ] > 2 ||
\t\t\tDepth[ expr[[2]] ] > 2 ||
\t\t\tDepth[ expr[[3]] ] > 2 ,

\t\t\tDo[ res2 = Parse[expr[[i]],res2],
\t\t\t\t{i,3}],

\t\t\tres2 = Union[res2,Flatten[{expr}]]\t\t
\t\t
\t\t]
\t];
\t
\tSelect[Sort[res2], (!SkipZQ[Head[#]])&]
\t];\
\>", "Input",
  Evaluatable->False,
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
SkipZQ[_] = False;
SkipZFunctions = {Less,Greater,Equal,GreaterEqual,LessEqual};
Unprotect[Evaluate[SkipZFunctions]];
Map[(# /: SkipZQ[#] = True)&, SkipZFunctions];
Protect[Evaluate[SkipZFunctions]];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ParseCommon[expr_,opt_:All] := Module[ {res1},

\tres1 = Select[Parse[expr], (!SkipZQ[Head[#]])&];
\t
\tIf[ SameQ[opt, All],
\t
\t\tres1 = Union[res1, CommonTermsAll[res1, Times], 
\t                       CommonTermsAll[res1, Plus]],
\t           
\t \tres1 = Union[res1, CommonTermsOne[res1, Times], 
\t                       CommonTermsOne[res1, Plus]]
\t\t];
\t\t
\t(* Print[\"parse = \", res1]; *)
\tres1\t
\t
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["better handling of expressions involving rationals:", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ParseRational[Times[Rational[n_,d_], x_?AtomQ]] := \
Times[Rational[n,d],x]\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["ParseRational[Times[Rational[n_,d_], x_]] := Parse[x]", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["ParseRational[x_] := x", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["Used by ZCount:", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ParseAll[expr_,res_:{}] := Module[ 

\t{n, i, j , res2, restemp, lres, temp1, temp2},

\tres2 = res;
\tn = Length[expr];

\tIf[Depth[expr] > 1,
\t\t
\t\tDo[ res2 = ParseAll[expr[[i]],res2],
\t\t\t{i,n}],

\t\tres2 = Union[res2,{expr}]
\t\t];
\t
\tSort[Flatten[{res2}]]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["new testing:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ToZTEST[rawexpr_, z_Symbol, nz_Integer, opts___] := Module[ 

\t{nz2,parse,copy,rules,n,i,zstr, znstr,temp,newrule,Parseopt,
\t Defaults, expr, nextparse},
\t
\tIfattributes = Attributes[If];
\tMap[ClearAttributes[If, #]&, Ifattributes];
\texpr = rawexpr /. {If[_,0,0] -> 0, RationalPowerRule, RationalProductRule};
\tMap[SetAttributes[If, #]&, Ifattributes];

\t(* Default options *)
\tDefaults = {Parse -> One};
\t
\tParseopt = Parse /. {opts} /. Defaults;
\tnz2 = nz;
\trules = {};
\tzstr = ToString[z];

\tparse = ParseCommon[expr,Parseopt];

\tIf[ !SameQ[parse,Union[Flatten[{expr}]]],
(*\tIf[ !SameQ[parse,RemoveRepeats[expr]],\t *)
(*\tIf[ !SameQ[parse,Sort[Flatten[{expr}]]], *)
\t
\t\t(* parse = Join[Select[parse,ZNumberQ],Select[parse, Depth[#] > 1 &]]; *)
\t\tparse = Select[parse, Depth[#] > 1 &];

\t\tn = Length[parse];\t
\t\tWhile[ n > 0,
\t\t
\t\t\t\t(* didn't make much difference *)
\t\t\t\t(* parse = Sort[parse, (Length[#1] < Length[#2])&]; *)
\t\t\t
\t\t\t\tparse = Sort[parse];
\t\t\t\t
\t\t\t\tnz2++;
\t\t\t\tznstr = StringJoin[zstr,ToString[nz2]];
\t\t\t\t
\t\t\t\tnextparse = parse[[1]];
\t\t\t\t
\t\t\t\t(* limit length of expressions *)
\t\t\t\tIf[ (Head[nextparse] === Times || Head[nextparse] === Plus) && 
\t\t\t\t\tLength[nextparse] > ZLengthLimit,
\t\t\t\t\tnextparse = Take[nextparse, ZLengthLimit]]; 
\t\t\t\t
\t\t\t\tnewrule = nextparse -> ToExpression[znstr];
\t\t\t\trules = Append[rules, newrule];
\t\t\t\t(* Print[zstr, nz2,\" = \", InputForm[nextparse],\";\"]; *)
\t\t\t\tPrintRule[newrule];
\t\t\t
\t\t\t\tparse = parse /. newrule;
\t\t\t
\t\t\t\t(* find new commmon sub-expressions *)
\t\t\t\t(*
\t\t\t\tIf[SameQ[Parseopt,All],
\t\t\t\tparse = Union[parse,ParseCommon[Select[parse,(Length[#] > \
2)&],Parseopt]];
\t\t\t\t\t];
\t\t\t\t*)
\t\t\t\t
\t\t\t\t(* parse = Join[Select[parse,ZNumberQ],Select[parse, Depth[#] > 1 \
&]]; *)
\t\t\t\tparse = Select[parse, Depth[#] > 1 &];
\t\t\t\t\t\t\t\t
\t\t\t\tn = Length[parse]
\t\t\t\t];

\t\tcopy = expr //. rules;
\t\t
\t\t(* recursive execution *)
\t\tIf[ Depth[copy] > 1,
\t\t\t\t\ttemp = ToZTEST[copy, z, nz2, opts];
\t\t\t\t\tcopy  = temp[[1]];
\t\t\t\t\trules = Join[rules, temp[[2]]];
\t\t\t\t\tnz2   = temp[[3]]
\t\t\t],
\t\t
\t\tIf[Verboseopt,\t
\t\t\tPrint[copy = expr];
\t\t\tPrintZ[z,nz2]
\t\t\t]
\t\t];
\t\t
\t{copy, rules, nz2}
\t
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ToZTEST[expr_,z_Symbol] := ToZTEST[expr,z,0];
ToZTEST[expr_] := ToZTEST[expr,z];
ToZTEST[expr_,opts___] := ToZTEST[expr,z,0,opts];
ToZTEST[expr_,z_Symbol,opts___] := ToZTEST[expr,z,0,opts];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Simple parsing function: ", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ParseSimple[expr_,res_:{}] := Module[ 

\t{n, i,j , res2, restemp, lres},

\tres2 = res;
\tn = Length[expr];

\tIf[Depth[expr] > 2,
\t\t
\t\tDo[ res2 = ParseSimple[expr[[i]],res2],
\t\t\t{i,n}],

\t\tIf[!MemberQ[res2,expr], 
\t\t\tres2 = Join[res2,{expr}]]
\t\t];
\t
\tFlatten[{res2}]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ToZSimple[expr_,z_,nz_] := Module[ 

\t{nz2,parse,copy,rules,n,i,zstr, znstr,temp},
\t
\tnz2 = nz;
\trules = {};
\tzstr = ToString[z];
\tparse = ParseSimple[expr];
\t
\tIf[ !SameQ[parse,Flatten[{expr}]],
\t\tn = Length[parse];
\t\t\t
\t\tDo[
\t\t\tIf[ Depth[parse[[i]]] > 1,
\t\t\t\tnz2++;
\t\t\t\tznstr = StringJoin[zstr,ToString[nz2]];
\t\t\t\trules = Join[rules, {parse[[i]] -> ToExpression[znstr]}];
\t\t\t\tPrint[zstr, nz2,\" = \", InputForm[parse[[i]]],\";\"]
\t\t\t\t]
\t\t\t\t,{i,n}
\t\t\t];
\t\t
\t\tcopy = expr //. rules;
\t\t
\t\tIf[ Depth[copy] > 1,
\t\t\t\t\ttemp = ToZSimple[copy, z, nz2];
\t\t\t\t\tcopy  = temp[[1]];
\t\t\t\t\trules = Join[rules, temp[[2]]];
\t\t\t\t\tnz2   = temp[[3]]
\t\t\t],
\t\t\t
\t\tPrint[copy = expr];
\t\tPrintZ[z,nz2]
\t\t];
\t\t
\t{copy, rules, nz2}
\t
\t];
ToZSimple[expr_,z_] := ToZSimple[expr,z,0];
ToZSimple[expr_] := ToZSimple[expr,z];\t\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["ZCompress:", "Subsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["User functions:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ZCompress[zout_, z_String, opts___] := Module[ 
\t
\t\t{ztab, rules, rtot, rn, zn, repl, zout2, zrt, zcount, rs,
\t\t shift, zrs, zrs1, empties, znmax, Verboseopt, Defaults},
\t\t
\t\t{zout2, rules, rtot} = zout;
\t\t
\t\t(* Defaults *)
\t\tDefaults = {Verbose -> True};
\t\tVerboseopt = Verbose /. {opts} /. Defaults;
\t\t
\t\t(* generate list of \"connectivities\" *)
\t\tztab = MakeZTab[zout, z];
\t\t\t\t
\t\t(* remove empty rules *)
\t\tempties = Position[ztab,{}];
\t\tIf[ Length[empties] > 0,
\t\t\tPrint[\"Found \", Length[empties], \" unused statements\"];
\t\t\trules = Delete[rules, empties];
\t\t\t
\t\t\t(* recalculate ztab *)
\t\t\tztab = MakeZTab[{zout2,rules,rtot}, z];
\t\t\tztab = Map[ (# /. {} -> 1)& , ztab]

\t\t\t];\t\t
\t\t
\t\tIf[Verboseopt,\t\t\t\t\t\t\t
\t\t\t(* PrintFortranRule[rules[[1]]]; *)\t\t\t\t\t\t\t
\t\t\tPrint[rules[[1]]]
\t\t];
\t\t
\t\tzcount = 0;
\t\tznmax  = 0;
\t\tFor[rn = 2, rn <= Length[rules], rn++,
\t\t
\t\t\t(* z number on the RHS *)
\t\t\tzrt = ZNumR[rules[[rn]],z];
\t\t\t
\t\t\t(* search ztab up to current label number *)
\t\t\tFor[zn = 1, zn < zrt, zn++,
\t\t\t
\t\t\t\t(* expired last flag *)
\t\t\t\tIf[ ztab[[zn]] <= rn,
\t\t\t\t
\t\t\t\t\tzcount++;
\t\t\t\t\tztab[[zn]] = ztab[[zrt]];
\t\t\t\t\tztab[[zrt]] = 0;
\t\t\t\t\t
\t\t\t\t\tshift = MakeRule[zrt, zn, z];
\t\t\t
\t\t\t\t\trules = Join[Take[rules, rn-1],
\t\t\t\t\t\t\t\t Take[rules, {rn, Length[rules]}] /. shift];
\t\t\t\t\t\t\t\t 
\t\t\t\t\tzout2 = zout2 /. shift;

\t\t\t\t\t zn = zrt  (* exit *)
\t\t\t\t\t] 
\t\t\t\t];
\t\t\t\t
\t\t\tznmax = Max[znmax,ZNumR[rules[[rn]],z]];
\t\t\tIf[Verboseopt,
\t\t\t\t(* PrintFortranRule[rules[[rn]]] *)
\t\t\t\t(* PrintRule[rules[[rn]]] *)
\t\t\t\tPrint[rules[[rn]]]
\t\t\t\t];
\t\t\t];
\t\t
\t\tIf[Verboseopt,
\t\t\tPrint[zout2];\t
\t\t\tPrintZ[z, znmax]
\t\t\t];
\t\t\t
\t\t{zout2, rules, znmax}
\t\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    \(\(ZCompress[zout_, opts___] := 
        ZCompress[zout, "\<z\>", opts];\)\)], "Input"],

Cell["version before revised flag expired searcher:", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ZCompress[zout_,z_:\"z\"] := Module[ 
\t
\t\t{ztab, rules, rtot, rn, zn, repl, zout2, zrt, zcount, rs,
\t\t shift, zrs, zrs1, empties, znmax},
\t\t
\t\t{zout2, rules, rtot} = zout;
\t\t
\t\t(* generate list of \"connectivities\" *)
\t\tztab = MakeZTab[zout, z];
\t\t\t\t
\t\t(* remove empty rules *)
\t\tempties = Position[ztab,{}];
\t\tIf[ Length[empties] > 0,
\t\t\tPrint[\"Found \", Length[empties], \" unused statements\\n\"];
\t\t\trules = Delete[rules, empties];
\t\t\t
\t\t\t(* recalculate ztab *)
\t\t\tztab = MakeZTab[{zout2,rules,rtot}, z];
\t\t\tztab = Map[ (# /. {} -> 1)& , ztab]

\t\t\t];\t\t
\t\t\t\t\t\t\t\t\t
\t\tPrintRule[rules[[1]]];
\t\t(* PrintFortranRule[rules[[1]]]; *)
\t\t
\t\tzcount = 0;
\t\tznmax  = 0;
\t\tFor[rn = 2, rn <= Length[rules], rn++,
\t\t
\t\t\t(* z number on the RHS *)
\t\t\tzrt = ZNumR[rules[[rn]],z];
\t\t\t
\t\t\t(* search ztab up to current label number *)
\t\t\tFor[zn = 1, zn < zrt, zn++,
\t\t\t
\t\t\t\t(* expired last flag *)
\t\t\t\tIf[ ztab[[zn]] <= rn,
\t\t\t\t
\t\t\t\t\tzcount++;
\t\t\t\t\tztab[[zn]] = ztab[[zrt]];
\t\t\t\t\t
\t\t\t\t\tshift = Join[ {MakeRule[zrt, zn, z]},
\t\t\t\t\t\t\tMap[ MakeRule[#, #-1,z]& , Range[zrt,rtot - zcount + 1]]];
\t\t\t\t\t\t\t\t\t\t\t                    (* is this right? *)
\t\t\t\t\tztab = Join[Take[ztab,zrt-1],
\t\t\t\t\t\t\t\tRotateLeft[Take[ztab,{zrt,rtot}]]];
\t\t\t
\t\t\t\t\trules = Join[Take[rules, rn-1],
\t\t\t\t\t\t\t\t Take[rules, {rn, Length[rules]}] /. shift];
\t\t\t\t\t\t\t\t 
\t\t\t\t\tzout2 = zout2 /. shift;

\t\t\t\t\t zn = rn  (* why is this rn and not zrt ? *)
\t\t\t\t\t(* zn = zrt *) (* exit *)
\t\t\t\t\t] 
\t\t\t\t];
\t\t\t\t
\t\t\tznmax = Max[znmax,ZNumR[rules[[rn]],z]];
\t\t\t(* PrintFortranRule[rules[[rn]]] *)
\t\t\t(* PrintRule[rules[[rn]]]*)
\t\t\tPrint[rules[[rn]]];
\t\t\t];
\t\t
\t\tPrint[zout2];\t
\t\tPrintZ[z, znmax];
\t\t\t
\t\t{zout2, rules, znmax}
\t\t];\
\>", "Input",
  Evaluatable->False,
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Utilities:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ZNum[zn_,z_:\"z\"] := Module[

\t{nz,t1},
\t
\tt1 = ToString[zn];
\tnz = StringLength[z];
\tToExpression[StringTake[t1,nz-StringLength[t1]]]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["ZNumR[rule_,z_:\"z\"] := ZNum[rule[[2]],z];", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
Znums[list_,z_:\"z\"] := Module[

\t{i, nlist, t1, zpos},
\t
\tnlist = {};
\tDo[
\t\tt1   = ToString[list[[i]]];
\t\tzpos = Flatten[StringPosition[t1,z]];
\t\t
\t\tIf[ Length[zpos] > 0,
\t\t\tnlist = Append[nlist,ZNum[list[[i]],z]]
\t\t\t]
\t\t\t
\t\t, {i,Length[list]}];
\t
\tnlist
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["not used!", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
FindFirstZ[rules_,n_,z_:\"z\"] := Module[

\t{zn, rn, out, rtot},

\trtot = Length[rules];
\tout = rtot + 1;
\tzn = ToExpression[StringJoin[z,ToString[n]]];
\t
\tFor[ rn = n+1, rn <= rtot, rn++,
\t\tIf[!FreeQ[rules[[rn,1]],zn],
\t\t\tout = rn;
\t\t\trn = rtot]
\t\t\t];
\t\t\t
\tout
\t];\
\>", "Input",
  Evaluatable->False,
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
FindLastZ[rules_,n_,z_:\"z\"] := Module[

\t{zn, rn, out, rtot},

\trtot = Length[rules];
\tout = rtot + 1;
\tzn = ToExpression[StringJoin[z,ToString[n]]];
\t
\tFor[ rn = rtot, rn > n, rn--,
\t\tIf[!FreeQ[rules[[rn,1]],zn],
\t\t\tout = rn;
\t\t\trn = n]
\t\t\t];
\t\t\t
\tout
\t];\
\>", "Input",
  Evaluatable->False,
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
MakeRule[znold_,znnew_,z_:\"z\"] :=

\tToExpression[StringJoin[z,ToString[znold]]] ->
\tToExpression[StringJoin[z,ToString[znnew]]];
\t\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
MakeRule[znold_,znnew_,z_:\"z\",Z_:\"Z\"] :=

\tToExpression[StringJoin[z,ToString[znold]]] ->
\tToExpression[StringJoin[Z,ToString[znnew]]];
\t\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
GenZList[n_Integer, z_String:\"z\"] := Module[

\t{outtab, i},
\t
\touttab = Table[ToString[i], {i,n}];
\tMap[ToExpression[StringJoin[z,#]]&,outtab]
\t
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
ReturnAtoms[expr_] := Union[Flatten[{Map[ If[Depth[#] > 1, \
ReturnAtoms[#], #]&,  Apply[List,expr] ]}]]\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
MakeZTab[zout_List, z_:\"z\"] := Module[ 

\t{zused, zout2, rules, rtot, zlist},
\t
\t{zout2, rules, rtot} = zout;
\t
\tzlist = GenZList[rtot,z];
\tzused = Append[Map[ReturnAtoms, Map[#[[1]]&,rules]],ReturnAtoms[zout2]];\t\t\

\tzused = Map[Intersection[zlist,#]&,zused];
\tzused = Map[Map[ZNum[#,z]&, zused[[#]]]&, Range[Length[zused]]];
\t\t\t
\t(* suppress error messages *)
\tOff[Last::nolast];
\tztab = Map[Last[Position[zused,#]][[1]]&, Range[rtot]];
\tOn[Last::nolast];

\tztab
\t
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["OutputZ:", "Subsection"],

Cell[CellGroupData[{

Cell["User functions:", "Subsubsection"],

Cell[BoxData[
    \(OutputZCForm[filename_String, \ zout_, opts___]\  := \ 
      Module[\[IndentingNewLine]{fp}, \[IndentingNewLine]fp = 
          OpenWrite[filename]; \[IndentingNewLine]OutputZCForm[fp, zout, 
          opts]; \[IndentingNewLine]Close[fp]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(\(OutputZCForm[fp_OutputStream, \ zout_, 
          opts___]\  := \[IndentingNewLine]Module[\[IndentingNewLine]{zout2, 
            rules, rtot, Zopt, \ 
            Defaults}, \[IndentingNewLine]\[IndentingNewLine] (*\ 
            Defaults\ *) \[IndentingNewLine]Defaults\  = \ {OutputArray \
\[Rule] False}; \[IndentingNewLine]Zopt\  = \ \(OutputArray\  /. \ {opts}\)\  \
/. \ Defaults; \[IndentingNewLine]Zopt\  = 
            If[Zopt\  \[NotEqual] \ True\  && \ Zopt\  \[NotEqual] \ False, 
              OutputArray /. Defaults, \ Zopt]; \[IndentingNewLine]{zout2, 
              rules, rtot} = zout; \[IndentingNewLine]Map[
            WriteString[fp, \(ZToString[CForm]\)[#, Zopt] <> "\<\n\>"] &, 
            rules];\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(LastWord[strIn_String] := 
      Module[\[IndentingNewLine]{str, pos, 
          last}, \[IndentingNewLine]\[IndentingNewLine]str = 
          strIn; \[IndentingNewLine]While[
          StringTake[str, \(-1\)] == "\< \>", \[IndentingNewLine]str = 
            StringDrop[
              str, \(-1\)]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]pos = StringPosition[str, "\< \>"]; \[IndentingNewLine]If[
          Length[pos] \[Equal] 0, \[IndentingNewLine]last = 
            str, \[IndentingNewLine]pos = 
            Last[Last[pos]]; \[IndentingNewLine]last = 
            StringTake[
              str, {pos + 1, 
                StringLength[
                  str]}]\[IndentingNewLine]]; \[IndentingNewLine]last\
\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(OutputZCCode[\[IndentingNewLine]funcname_String, \ \
\[IndentingNewLine]commonfile_String, \[IndentingNewLine]arglist_List, \ \
\[IndentingNewLine]maxZ_, \[IndentingNewLine]zout_] \
:= \[IndentingNewLine]Module[\[IndentingNewLine]{common, \ zopts, nz, 
          i}, \[IndentingNewLine]\[IndentingNewLine] (*\ 
          must\ output\ Z' s\ as\ an\ array\ *) \[IndentingNewLine]zopts = 
          OutputArray \[Rule] 
            True; \[IndentingNewLine]\[IndentingNewLine] (*\ 
          get\ the\ common\ code\ to\ be\ inserted\ at\ the\ top\ of\ ever\ \
function\ *) \[IndentingNewLine]fpc\  = \ 
          OpenRead[commonfile]; \[IndentingNewLine]If[
          fpc === $Failed, \[IndentingNewLine]Print["\<Could not open common \
file:\>" <> 
              commonfile]; \[IndentingNewLine]Return[]\[IndentingNewLine]]; \
\[IndentingNewLine]common = ReadList[fpc, Record]; \[IndentingNewLine]Close[
          fpc]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
          setup\ *) \[IndentingNewLine]nz = 
          zout[\([3]\)]; \[IndentingNewLine]zoutParts = 
          Partition[zout[\([2]\)], maxZ, 
            maxZ, {1, 1}, {}]; \[IndentingNewLine]args = 
          Apply[StringJoin, 
            Append[Drop[Map[\((# <> "\<,\>")\) &, \ arglist], \(-1\)], 
              arglist[\([\(-1\)]\)]]]; \[IndentingNewLine]arglistAll = 
          Append[arglist, "\<double* z\>"]; \[IndentingNewLine]argsAll = 
          Apply[StringJoin, 
            Append[Drop[Map[\((# <> "\<,\>")\) &, \ arglistAll], \(-1\)], 
              arglistAll[\([\(-1\)]\)]]]; \[IndentingNewLine]arglistAllname = 
          Map[LastWord, arglistAll]; \[IndentingNewLine]arglAllname = 
          Apply[StringJoin, 
            Append[Drop[Map[\((# <> "\<,\>")\) &, \ arglistAllname], \(-1\)], 
              arglistAllname[\([\(-1\)]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine] (*\ driver\ function\ *) \[IndentingNewLine]fpd\  = \ 
          OpenWrite[
            funcname <> "\<_driver.c\>"]; \[IndentingNewLine]WriteString[
          fpd, "\<#include <stdlib.h>\n\>"]; \[IndentingNewLine]WriteString[
          fpd, "\<void \>" <> funcname <> "\<_driver(\>" <> 
            args <> "\<);\n\>"]; \[IndentingNewLine]For[i = 1, \ 
          i \[LessEqual] 
            Length[zoutParts], \ \(i++\), \[IndentingNewLine]WriteString[
            fpd, "\<void \>" <> funcname <> "\<_\>" <> 
              ToString[i] <> "\<(\>" <> 
              argsAll <> "\<);\n\>"]\[IndentingNewLine]]; \
\[IndentingNewLine]WriteString[
          fpd, "\<void \>" <> funcname <> "\<_driver(\>" <> 
            args <> "\<) {\n\>"]; \[IndentingNewLine]WriteString[
          fpd, "\<\t\>" <> "\<double* z = (double*) malloc(\>" <> 
            ToString[
              nz + 1] <> "\<*sizeof(double));\n\>"]; \[IndentingNewLine]For[
          i = 1, \ i \[LessEqual] 
            Length[zoutParts], \ \(i++\), \[IndentingNewLine]WriteString[
            fpd, "\<\t\>" <> funcname <> "\<_\>" <> ToString[i] <> "\<(\>" <> 
              arglAllname <> "\<);\n\>"]\[IndentingNewLine]]; \
\[IndentingNewLine] (*\ close\ function\ *) \[IndentingNewLine]WriteString[
          fpd, "\<\t\>" <> "\<free(z);\n\>"]; \[IndentingNewLine]WriteString[
          fpd, "\<}\n\>"]; \[IndentingNewLine]Close[
          fpd]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
          write\ each\ block\ to\ a\ separate\ file, \ 
          add\ calls\ to\ the\ driver\ function\ *) \[IndentingNewLine]For[
          i = 1, \ i \[LessEqual] 
            Length[zoutParts], \ \(i++\), \[IndentingNewLine]\
\[IndentingNewLine] (*\ open\ out\ file\ *) \[IndentingNewLine]fpd\  = \ 
            OpenWrite[
              funcname <> "\<_\>" <> 
                ToString[i] <> "\<.c\>"]; \[IndentingNewLine]WriteString[
            fpd, "\<#include <math.h>\n\>"]; \[IndentingNewLine]WriteString[
            fpd, "\<void \>" <> funcname <> "\<_\>" <> 
              ToString[i] <> "\<(\>" <> 
              argsAll <> "\<);\n\>"]; \[IndentingNewLine]WriteString[
            fpd, "\<void \>" <> funcname <> "\<_\>" <> 
              ToString[i] <> "\<(\>" <> 
              argsAll <> "\<) {\n\>"]; \[IndentingNewLine]\[IndentingNewLine] \
(*\ common\ code\ *) \[IndentingNewLine]Map[
            WriteString[fpd, # <> "\<\n\>"] &, 
            common]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
            write\ the\ Z\ code\ *) \[IndentingNewLine]OutputZCForm[
            fpd, \ {0, zoutParts[\([i]\)], 0}, 
            zopts]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
            close\ out\ file\ *) \[IndentingNewLine]WriteString[
            fpd, "\<}\n\>"]; \[IndentingNewLine]Close[
            fpd]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]i\
\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(OutputZFortranForm[filename_String, \ zout_, opts___]\  := \ 
      Module[\[IndentingNewLine]{fp, zout2, rules, rtot, Zopt, \ 
          Defaults}, \[IndentingNewLine]\[IndentingNewLine] (*\ 
          Defaults\ *) \[IndentingNewLine]Defaults\  = \ {OutputArray \[Rule] 
              False}; \[IndentingNewLine]Zopt\  = \ \(OutputArray\  /. \ \
{opts}\)\  /. \ Defaults; \[IndentingNewLine]Zopt\  = 
          If[Zopt\  \[NotEqual] \ True\  && \ Zopt\  \[NotEqual] \ False, 
            OutputArray /. Defaults, \ 
            Zopt]; \[IndentingNewLine]\[IndentingNewLine]fp = 
          OpenWrite[filename]; \[IndentingNewLine]{zout2, rules, rtot} = 
          zout; \[IndentingNewLine]Map[
          WriteString[fp, \(ZToString[FortranForm]\)[#, Zopt] <> "\<\n\>"] &, 
          rules]; \[IndentingNewLine]Close[fp]\[IndentingNewLine]]\)], "Input"],

Cell["\<\
PrintRule[format_][rule_Rule, \
Zopt_]:=Print[ZToString[format][rule,Zopt]];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["General formatting:", "Subsubsection"],

Cell[BoxData[
    \(\(\(ConvertArrayZ[format_]\)[str_String, z_: "\<z\>"] := 
        Module[\[IndentingNewLine]{pos, \ zstr, 
            strNew}, \[IndentingNewLine]zstr = 
            Map[\((z <> #)\) &, 
              CharacterRange["\<1\>", "\<9\>"]]; \[IndentingNewLine]pos = 
            StringPosition[str, zstr]; \[IndentingNewLine]pos = 
            Map[FindZBounds[str, #] &, pos]; \[IndentingNewLine]pos = 
            Select[pos, \((#[\([1]\)] \[Equal] 
                      1 || \(! LetterQ[
                        StringTake[
                          str, {#[\([1]\)] - 1, #[\([1]\)] - 
                              1}]]\))\) &]; \[IndentingNewLine]If[
            Length[pos] > 0, \[IndentingNewLine]strNew = 
              StringInsert[str, 
                StringTake[
                  ArrayBrackets[format], {1, 
                    1}], \(Transpose[pos]\)[\([1]\)] + 
                  1]; \[IndentingNewLine]StringInsert[strNew, 
              StringTake[ArrayBrackets[format], {2, 2}], 
              1 + \(Transpose[pos]\)[\([2]\)] + 
                Range[Length[
                    pos]]], \[IndentingNewLine]str\[IndentingNewLine]]\
\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(\(FindZBounds[str_String, position_List] := 
        Module[\[IndentingNewLine]{i, ret}, \[IndentingNewLine]ret = 
            position; \[IndentingNewLine]i = 
            ret[\([2]\)]; \[IndentingNewLine]While[
            i <= StringLength[str] && 
              DigitQ[StringTake[
                  str, {i, 
                    i}]], \[IndentingNewLine]\(i++\)\[IndentingNewLine]]; \
\[IndentingNewLine]ret[\([2]\)] = 
            i - 1; \[IndentingNewLine]ret\[IndentingNewLine]];\)\)], "Input"],

Cell[TextData[{
  "ZForm[format_][x_,Zarray_]:= Module[\n\t{xstr},\n\txstr = \
ToString[format[x] /. ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "2Functions[format] //N];\n\txstr = If[StringLength[xstr] > 4 && \
StringTake[xstr,4] == \"-1.*\", StringDrop[xstr,{2,4}], xstr];\n\t\n\t(* \
output Z's as arrays *)\n\txstr = If[",
  "Zarray",
  ",ConvertArrayZ[format][xstr], xstr];\n\txstr\n\t];"
}], "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "Functions = {Power, Sqrt,\n                        Log, \n                 \
       Sin, Cos, Tan, \n                        ArcSin, ArcCos, ArcTan,\n     \
                   Sinh, Cosh, Tanh, Sign};"
}], "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]],

Cell[CellGroupData[{

Cell["OutputForm (screen):", "Subsubsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox[
            RowBox[{
              StyleBox["Mathematica",
                FontSlant->"Italic"], "2Functions"}]], "[", "OutputFormat", 
          "]"}], "=", \({}\)}], ";"}]], "Input"],

Cell[BoxData[{
    \(\(TabOut[OutputForm] := "\<\t\>";\)\), "\n", 
    \(\(Assign[OutputForm] := "\< = \>";\)\), "\n", 
    \(\(LineEnding[OutputForm] := "\<\>";\)\), "\[IndentingNewLine]", 
    \(\(ArrayBrackets[OutputForm] := "\<[]\>";\)\)}], "Input"],

Cell["\<\
ZForm[OutputForm][x_,Zopt_{False,True}]:=ToString[InputForm[x]];\
\>\
", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    \(\(ZToString[OutputForm]\)[rule_Rule, Zopt_] := 
      TabOut[OutputForm] <> \(ZForm[OutputForm]\)[rule[\([2]\)], Zopt] <> 
        Assign[OutputForm] <> \(ZForm[OutputForm]\)[rule[\([1]\)], Zopt] <> 
        LineEnding[OutputForm]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["C/C++:", "Subsubsection"],

Cell["C form with \"if\" expressions and function tranlsations:", "Text",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
Off[General::spell1];
CFunctions = {pow, sqrt,
              log,
              sin, cos, tan,
              asin, acos, atan,
              sinh, cosh, tanh, sign};
Unprotect[Evaluate[CFunctions], exp];
Map[Clear, CFunctions];
On[General::spell1];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "2Functions[CForm] = Join[{Power[E,x_] -> exp[x],\n\tPower[x_,2] -> \
HoldForm[x x],\n\tPower[x_,-1] -> HoldForm[1/x],\n    Power[x_,-2] -> \
HoldForm[1/(x x)],\n\tPower[x_,Rational[1,2]] -> HoldForm[sqrt[x]],\n\t\
Power[x_,Rational[-1,2]] -> HoldForm[1/sqrt[x]]},\n\tMapThread[Rule, {",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "Functions, CFunctions}]];\nProtect[Evaluate[CFunctions], exp];"
}], "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[{
    \(\(TabOut[CForm] := "\<\t\>";\)\), "\n", 
    \(\(Assign[CForm] := "\< = \>";\)\), "\n", 
    \(\(LineEnding[CForm] := "\<;\>";\)\), "\[IndentingNewLine]", 
    \(\(ArrayBrackets[CForm] := "\<[]\>";\)\)}], "Input"],

Cell[BoxData[
    \(\(ZToString[CForm]\)[rule_Rule, Zopt_] := \[IndentingNewLine]If[
        Head[rule[\([1]\)]] === 
          If, \[IndentingNewLine]TabOut[CForm] <> \(ZForm[CForm]\)[
            rule[\([2]\)], Zopt] <> 
          Assign[CForm] <> "\<(\>" <> \(ZForm[CForm]\)[rule[\([1, 1]\)], 
            Zopt] <> "\<) ? \>" <> \(ZForm[CForm]\)[rule[\([1, 2]\)], 
            Zopt] <> "\< : \>" <> \(ZForm[CForm]\)[rule[\([1, 3]\)], Zopt] <> 
          LineEnding[CForm]\[IndentingNewLine],  (*\ 
          else\ *) \[IndentingNewLine]TabOut[CForm] <> \(ZForm[CForm]\)[
            rule[\([2]\)], Zopt] <> 
          Assign[CForm] <> \(ZForm[CForm]\)[rule[\([1]\)], Zopt] <> 
          LineEnding[CForm]\[IndentingNewLine]]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Fortran:", "Subsubsection"],

Cell[CellGroupData[{

Cell["\<\
Off[General::spell1];
FortranFunctions = {Power, dsqrt,
              dlog,
              dsin, dcos, dtan,
              dasin, dacos, datan,
              dsinh, dcosh, dtanh, sign};   
Unprotect[Evaluate[FortranFunctions], exp]
Map[Clear, FortranFunctions];
On[General::spell1];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    \({"Power", "sign", "exp"}\)], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "2Functions[FortranForm] = Join[{Power[E,x_] -> dexp[x],\n\t\t\t\t\
Power[x_,2] -> HoldForm[x x],\n\t\t\t\tPower[x_,-1] -> HoldForm[1/x],\n    \
Power[x_,-2] -> HoldForm[1/(x x)],\n\t\t\t\tPower[x_,Rational[1,2]] -> \
HoldForm[dsqrt[x]],\n\t\t\t\tPower[x_,Rational[-1,2]] -> \
HoldForm[1/dsqrt[x]]},\n\t\t\t\tMapThread[Rule, {",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "Functions, FortranFunctions}]];\nProtect[Evaluate[FortranFunctions], \
exp];"
}], "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(dexp\\)\\\" is similar to existing symbol \\\
\"\\!\\(exp\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\
\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"]
}, Open  ]],

Cell[BoxData[{
    \(\(TabOut[FortranForm] := "\<      \>";\)\), "\n", 
    \(\(Assign[FortranForm] := "\< = \>";\)\), "\n", 
    \(\(LineEnding[FortranForm] := "\<\>";\)\), "\[IndentingNewLine]", 
    \(\(ArrayBrackets[FortranForm] := "\<()\>";\)\)}], "Input"],

Cell[BoxData[
    \(\(\(ZToString[FortranForm]\)[rule_Rule, Zopt_] := \[IndentingNewLine]If[
          Head[rule[\([1]\)]] === 
            If, \[IndentingNewLine]TabOut[
              FortranForm] <> "\<if (\>" <> \(ZForm[FortranForm]\)[
              rule[\([1, 1]\)], 
              Zopt] <> "\<) then\n\>"\[IndentingNewLine] <> \(ZToString[
                FortranForm]\)[rule[\([1, 2]\)] \[Rule] rule[\([2]\)], 
              Zopt] <> "\<\n\>" <> 
            TabOut[FortranForm] <> "\<else\n\>" <> \(ZToString[FortranForm]\)[
              rule[\([1, 3]\)] \[Rule] rule[\([2]\)], Zopt] <> "\<\n\>" <> 
            TabOut[FortranForm] <> "\<endif\>"\[IndentingNewLine], \  (*\ 
            else\ *) \[IndentingNewLine]TabOut[
              FortranForm] <> \(ZForm[FortranForm]\)[rule[\([2]\)], Zopt] <> 
            Assign[FortranForm] <> \(ZForm[FortranForm]\)[rule[\([1]\)], 
              Zopt] <> LineEnding[
              FortranForm]\[IndentingNewLine]];\)\)], "Input"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Operation Count:", "Subsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["User functions:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
OpCount[expr_] := Module[ 

\t{Functs, ff, pow, str, i, minss, commas},

\tFuncts = {\"Cos\",\"Sin\",\"Tan\",\"Exp\",\"Sec\",\"Csc\",\"Cot\"};

\tcommas = Length[StringPosition[ToString[expr],\",\"]];
\tpow = PowerCount[expr];
\tstr = ToString[FullForm[expr]];
\tstr = StringJoin[str,Table[\",\", {pow}]];
\t
\tDo[ str = StringReplace[str, Functs[[i]] -> \",\"];
\t\t\t,{i,Length[Functs]}];
\t
\t(* correct for all *-1 *)
\tminss = Length[StringPosition[str,\"Times[-1\"]];
\t
\tLength[StringPosition[str,\",\"]] - minss - commas
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["\<\
OpZCount[zout_,prnt_:False] := Module[ {n, ops, rules, temp},

\tops = 0;
\trules = zout[[2]];
\tn = Length[rules];
\t
\tDo[ 
\t\ttemp = OpCount[rules[[i,1]]];
\t\tops = ops + temp;
\t\tIf[ prnt, Print[rules[[i,1]],\" = \", temp]]
\t\t, {i,n}];
\t
\ttemp = OpCount[zout[[1]]];
\tIf[prnt, Print[zout[[1]],\" = \", temp]];

\tops = ops + temp
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(OpZCount\\)\\\" is similar to existing \
symbol \\\"\\!\\(OpCount\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Utility:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
PowerCount[expr_] := Module[

\t {ff, ps, count, i, pos, expo},

\tff = FullForm[expr];

\t(* list of the positions of terms with powers *)\t
\tps = Position[ff,Power];\t
\tcount = 0;
\t
\tDo[
\t\t(* convert position of power to the index 
\t\t   of the actual exponent *)
\t\tpos = ReplacePart[ps[[i]],2,-1];

\t\t(* grab the exponent by stripping the list
\t\t   of its Head *)
\t\texpo = ff[[Delete[pos,0]]];
\t\t
\t\tIf[IntegerQ[expo],
\t\t\tIf[ expo > 0,
\t\t\t\texpo -= 2,
\t\t\t\tIf[ expo < 0,
\t\t\t\t\texpo = Abs[expo] - 1]];
\t\t\tcount += expo
\t\t\t]
\t\t,{i, Length[ps]}];
\t\t
\tcount
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Plot Z:", "Subsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["Utilities:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[CellGroupData[{

Cell["\<\
ZCount[rules_,z_:\"z\"] := Module[

\t{nrules,outtab, i, t1},
\t
\tnrules = Length[rules];
\touttab = Table[ {}, {nrules}];
\t
\tDo[
\t\tt1 = ParseAll[rules[[i,1]]];
\t\touttab[[ZNumR[rules[[i]],z]]] = 
\t\t\tJoin[outtab[[ZNumR[rules[[i]],z]]],
\t\t \t\t Znums[t1,z]]
\t\t, {i,nrules}];
\t
\touttab
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(ZCount\\)\\\" is similar to existing symbol \
\\\"\\!\\(Count\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
    RowBox[{\(General::"spell1"\), \(\(:\)\(\ \)\), "\<\"Possible spelling \
error: new symbol name \\\"\\!\\(nrules\\)\\\" is similar to existing symbol \
\\\"\\!\\(rules\\)\\\". \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell1\\\"]\\)\"\>"}]], "Message"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Functions:", "Subsubsection",
  ImageRegion->{{0, 1}, {0, 1}}],

Cell["\<\
PlotZCount[rules_,z_:\"z\"] := Module[

\t{pts, ztab, i},
\t
\tpts = {};
\tztab = ZCount[rules,z];
\t
\tDo[
\t\tpts = Join[pts, Map[Point,
\t\t\t\tFlatten[Outer[List,{i},ztab[[i]]],1]]]
\t\t,{i, Length[ztab]}];
\t\t\t
\tGraphics[pts]
\t];\
\>", "Input",
  ImageRegion->{{0, 1}, {0, 1}}]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Restore evaluation options:", "Subsection"],

Cell[BoxData[{
    \(\(On[General::spell];\)\), "\[IndentingNewLine]", 
    \(\(On[General::spell1];\)\)}], "Input"]
}, Closed]]
},
FrontEndVersion->"5.0 for Macintosh",
ScreenRectangle->{{0, 1635}, {0, 1028}},
WindowToolbars->{},
WindowSize->{655, 966},
WindowMargins->{{Automatic, 0}, {Automatic, 0}},
PrivateNotebookOptions->{"ColorPalette"->{RGBColor, -1}},
ShowSelection->True,
ShowCellLabel->True,
ShowCellTags->False,
RenderingOptions->{"ObjectDithering"->True,
"RasterDithering"->False}
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{
Cell[1754, 51, 108, 1, 44, "Subsubsection"],

Cell[CellGroupData[{
Cell[1887, 56, 69, 1, 38, "Subsection"],
Cell[1959, 59, 1365, 47, 140, "Text"],
Cell[3327, 108, 5103, 156, 660, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[8467, 269, 45, 0, 30, "Subsection"],
Cell[8515, 271, 118, 2, 43, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[8670, 278, 59, 1, 30, "Subsection"],

Cell[CellGroupData[{
Cell[8754, 283, 73, 1, 44, "Subsubsection"],
Cell[8830, 286, 2687, 98, 1542, "Input"],
Cell[11520, 386, 215, 6, 72, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[11772, 397, 68, 1, 38, "Subsubsection"],
Cell[11843, 400, 68, 1, 27, "Input"],
Cell[11914, 403, 84, 1, 32, "Text"],
Cell[12001, 406, 72, 1, 27, "Input"],
Cell[12076, 409, 128, 4, 27, "Input"],
Cell[12207, 415, 131, 4, 42, "Input"],
Cell[12341, 421, 140, 4, 42, "Input"],
Cell[12484, 427, 144, 4, 42, "Input"],
Cell[12631, 433, 405, 18, 252, "Input"],
Cell[13039, 453, 223, 11, 147, "Input"],
Cell[13265, 466, 426, 23, 327, "Input"],
Cell[13694, 491, 65, 1, 32, "Text"],
Cell[13762, 494, 108, 1, 27, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[13907, 500, 87, 1, 38, "Subsubsection"],
Cell[13997, 503, 266, 11, 32, "Text"],
Cell[14266, 516, 302, 12, 162, "Input"],
Cell[14571, 530, 636, 26, 387, "Input"],
Cell[15210, 558, 341, 15, 32, "Text"],
Cell[15554, 575, 95, 1, 32, "Text"],
Cell[15652, 578, 182, 5, 72, "Input"],
Cell[15837, 585, 158, 7, 32, "Text"],
Cell[15998, 594, 167, 5, 57, "Input"],
Cell[16168, 601, 66, 1, 27, "Input"],
Cell[16237, 604, 170, 7, 32, "Text"],
Cell[16410, 613, 699, 39, 552, "Input",
  Evaluatable->False],
Cell[17112, 654, 257, 7, 87, "Input"],
Cell[17372, 663, 477, 19, 267, "Input"],
Cell[17852, 684, 100, 1, 32, "Text"],
Cell[17955, 687, 133, 4, 42, "Input"],
Cell[18091, 693, 103, 1, 27, "Input"],
Cell[18197, 696, 72, 1, 27, "Input"],
Cell[18272, 699, 64, 1, 32, "Text"],
Cell[18339, 702, 331, 19, 267, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[18707, 726, 70, 1, 38, "Subsubsection"],
Cell[18780, 729, 2394, 88, 1377, "Input"],
Cell[21177, 819, 247, 6, 72, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[21461, 830, 83, 1, 38, "Subsubsection"],
Cell[21547, 833, 347, 20, 282, "Input"],
Cell[21897, 855, 944, 42, 627, "Input"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[22890, 903, 65, 1, 38, "Subsection"],

Cell[CellGroupData[{
Cell[22980, 908, 73, 1, 28, "Subsubsection"],
Cell[23056, 911, 1921, 76, 1122, "Input"],
Cell[24980, 989, 106, 2, 27, "Input"],
Cell[25089, 993, 94, 1, 30, "Text"],
Cell[25186, 996, 1968, 71, 1032, "Input",
  Evaluatable->False]
}, Closed]],

Cell[CellGroupData[{
Cell[27191, 1072, 68, 1, 22, "Subsubsection"],
Cell[27262, 1075, 203, 10, 132, "Input"],
Cell[27468, 1087, 93, 1, 27, "Input"],
Cell[27564, 1090, 345, 19, 267, "Input"],
Cell[27912, 1111, 58, 1, 32, "Text"],
Cell[27973, 1114, 367, 19, 252, "Input",
  Evaluatable->False],
Cell[28343, 1135, 360, 19, 252, "Input",
  Evaluatable->False],
Cell[28706, 1156, 193, 7, 87, "Input"],
Cell[28902, 1165, 202, 7, 87, "Input"],
Cell[29107, 1174, 214, 10, 132, "Input"],
Cell[29324, 1186, 162, 4, 42, "Input"],
Cell[29489, 1192, 550, 22, 312, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[30088, 1220, 30, 0, 30, "Subsection"],

Cell[CellGroupData[{
Cell[30143, 1224, 40, 0, 44, "Subsubsection"],
Cell[30186, 1226, 291, 4, 123, "Input"],
Cell[30480, 1232, 781, 12, 235, "Input"],
Cell[31264, 1246, 787, 16, 267, "Input"],
Cell[32054, 1264, 4767, 81, 1483, "Input"],
Cell[36824, 1347, 872, 13, 299, "Input"],
Cell[37699, 1362, 134, 4, 42, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[37870, 1371, 44, 0, 38, "Subsubsection"],
Cell[37917, 1373, 1201, 23, 379, "Input"],
Cell[39121, 1398, 521, 10, 203, "Input"],
Cell[39645, 1410, 452, 11, 177, "Input"],
Cell[40100, 1423, 318, 7, 87, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[40455, 1435, 45, 0, 38, "Subsubsection"],
Cell[40503, 1437, 263, 8, 27, "Input"],
Cell[40769, 1447, 253, 4, 75, "Input"],
Cell[41025, 1453, 124, 4, 27, "Input"],
Cell[41152, 1459, 263, 4, 75, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[41452, 1468, 31, 0, 38, "Subsubsection"],
Cell[41486, 1470, 106, 1, 32, "Text"],
Cell[41595, 1473, 306, 11, 147, "Input"],
Cell[41904, 1486, 522, 11, 132, "Input"],
Cell[42429, 1499, 234, 4, 75, "Input"],
Cell[42666, 1505, 740, 12, 171, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[43443, 1522, 33, 0, 38, "Subsubsection"],

Cell[CellGroupData[{
Cell[43501, 1526, 339, 11, 147, "Input"],
Cell[43843, 1539, 58, 1, 70, "Output"]
}, Open  ]],

Cell[CellGroupData[{
Cell[43938, 1545, 577, 13, 147, "Input"],
Cell[44518, 1560, 355, 5, 70, "Message"]
}, Open  ]],
Cell[44888, 1568, 261, 4, 75, "Input"],
Cell[45152, 1574, 980, 16, 219, "Input"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[46181, 1596, 71, 1, 38, "Subsection"],

Cell[CellGroupData[{
Cell[46277, 1601, 73, 1, 28, "Subsubsection"],
Cell[46353, 1604, 592, 21, 297, "Input"],

Cell[CellGroupData[{
Cell[46970, 1629, 403, 19, 267, "Input"],
Cell[47376, 1650, 363, 5, 70, "Message"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[47788, 1661, 66, 1, 22, "Subsubsection"],
Cell[47857, 1664, 661, 32, 462, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[48567, 1702, 62, 1, 30, "Subsection"],

Cell[CellGroupData[{
Cell[48654, 1707, 68, 1, 28, "Subsubsection"],

Cell[CellGroupData[{
Cell[48747, 1712, 361, 18, 252, "Input"],
Cell[49111, 1732, 359, 5, 70, "Message"],
Cell[49473, 1739, 359, 5, 70, "Message"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{
Cell[49881, 1750, 68, 1, 28, "Subsubsection"],
Cell[49952, 1753, 296, 16, 222, "Input"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[50297, 1775, 49, 0, 30, "Subsection"],
Cell[50349, 1777, 116, 2, 43, "Input"]
}, Closed]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

